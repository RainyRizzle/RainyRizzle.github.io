<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <!-- 제목 -->
        <title>カスタムシェーダー</title>
        <!-- 파비콘 -->
        <link rel="shortcut icon" href="../../Images/favicon.ico"/>
        <!-- 부트스트랩 -->
        <link rel="stylesheet" href="../../css/bootstrap.css">
        <!--------------->

    </head>

    <body>
        <p>
            <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
            <!--로고 : AnyPortrait 홈페이지로 가야한다. (언어별)-->
            <a class="navbar-brand" href="https://www.rainyrizzle.com/anyportrait-jp">
                <img src="../../Images/AP_Logo.png" width="150" height="30" class="d-inline-block align-top" alt="">
            </a>

            <!--메뉴들 : 현재 페이지의 카테고리에 active 붙인다. (언어별 링크) -->
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarText">
                <ul class="navbar-nav mr-auto">
                <li class="nav-item">
                    <a class="nav-link" href="../../jp/GettingStarted.html">入門ガイド</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../../jp/AdManual.html">マニュアル</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../jp/Script.html">スクリプト</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://www.rainyrizzle.com/ap-videotutorial-jp">ビデオ</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://www.rainyrizzle.com/ap-forum">フォーラム</a>
                </li>

                </ul>

                <!-- 언어 변경. 현재 페이지의 주소에서 언어 주소만 변경한다. (해당 언어에 active) -->
                <div class="btn-group mr-2" role="group" aria-label="Basic example">
                    <a role="button" class="btn btn-secondary" href="../../en/Script/SC_CustomShader.html">EN</a>
                    <a role="button" class="btn btn-secondary" href="../../kr/Script/SC_CustomShader.html">KR</a>
                    <a role="button" class="btn btn-secondary active" href="../../jp/Script/SC_CustomShader.html">JP</a>
                </div>

                <!-- 여백 -->
                <p></p>

                <!-- 검색버튼 -->
                <form class="form-inline">
                    <a class="btn btn-light" role="button" href="../../jp/Search.html">サーチ</a>
                </form>
            </div>
        </nav>
    </p>

    <!-- 실제 바디 부분 -->
    <div class="container">
    <br>
    <br>
    <!-- 여기에 내용을 적어주세요 -->

    <!-- 여기서부터 페이지 내용이 작성됩니다. -->
    <!-- 1. 페이지 진입 경로 -->
    <p><a href="https://www.rainyrizzle.com/anyportrait-jp"><span class="text-dark">AnyPortrait</span></a> > <a href="../../jp/Script.html"><span class="text-dark">スクリプト</span></a> > カスタムシェーダー</p>
    
    <!-- 2. 페이지 메인 타이틀 -->
    <h1 class="display-5">カスタムシェーダー</h1>
    <br>
    
    <!-- 4. 버전 설명 -->
    <h4><span class="badge badge-secondary">1.6.0</span></h4>
    
    <p>
    AnyPortraitは一般的に使用されるさまざまなシェーダを提供しますが、プロジェクトによっては特殊な効果を加えたカスタムシェーダを作成する必要もあります。<br>
    AnyPortraitのわずかな規則に準拠している場合は、カスタムシェーダを簡単に作成して素晴らしいレンダリング結果を作成できます。<br>
    このページでは、AnyPortraitのシェーダ基本型がどのように設定されているかについて説明します。<br>
    この説明に基づいてカスタムシェーダを作成して適用してください。<br>
    </p>
    <br>
    
    <p>
    作成したシェーダを適用したい場合は、「マテリアルライブラリ」を利用するか、メッシュのプロパティを変更するだけです。<br>
    シェーダを変更する方法については、次のマニュアルを確認してください。<br>
    - <a href="../../jp/AdvancedManual/AD_MaterialLibrary.html">マテリアルライブラリ</a><br>
    - <a href="../../jp/AdvancedManual/AD_MeshShader.html">メッシュ用シェーダ(Shader)</a><br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>メモ</strong></span><br>
    このページでは、シェーダの作成方法については説明しません。<br>
    関連する内容については、Unityドキュメントやフォーラム、関連サイトをご覧ください！<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>AnyPortraitで使用されるシェーダの種類</h3>
    <br>
    
    <p>
    AnyPortraitは、1つのシェーダを使用するのではなく、複数のシェーダのうちの状況に合ったシェーダを使用します。<br>
    シェーダが派生する3つの要因に応じて、合計17個のシェーダが1つのセットを成して適用されます。 （<a href="../../jp/AdvancedManual/AD_MaterialLibrary.html">関連ページ</a>）<br>
    その要因は次のとおりです。<br>
    </p>
    <br>
    
    <p>
    <strong>1. カラースペース(Color Space)</strong><br>
    プロジェクトの色空間によってシェーダが決まります。<br>
    「<strong>Gamma Space</strong>」に基づいて作成され、「<strong>Linear Space</strong>」の場合は色演算式が変更されます。<br>
    </p>
    <br>
    
    <p>
    <strong>2. ブレンディング(Blending)</strong><br>
    メッシュは、4種類のブレンドのいずれかの方法でレンダリングされます。<br>
    デフォルトの「<strong>Alpha Blend</strong>」に基づいて作成され、「<strong>Additive</strong>」、「<strong>Soft Additive</strong>」、「<strong>Multiplicative</strong>」では、ブレンド属性とアルファ値演算に関連するコードが少し変更されます。<br>
    </p>
    <br>
    
    <p>
    <strong>3. クリッピング(Clipping)</strong><br>
    クリッピングメッシュはマスクテクスチャ情報を受け取り、アルファ演算をさらに実行します。<br>
    マスクを生成する1つのシェーダも含まれていますが、これは固定された役割を果たす機能性シェーダです。<br>
    </p>
    <br>
    
    <p>
    上記の要因が組み合わせられ、合計17個のシェーダがキャラクターに適用されます。<br>
    しかし、カスタムシェーダーを作成したい場合は、あえてすべてのシェーダーを作成する必要はありません。<br>
    次の点をチェックして、あなたのプロジェクトの状況に合ったシェーダーだけを作成します。<br>
    </p>
    <br>
    
    <p>
    - プロジェクトの色空間に応じて、<strong>Gamma</strong>や<strong>Linear</strong>のいずれかのタイプのシェーダーのみ作成してください。<br>
    - ブレンディングオプションを使用しない場合は、基本的な方法である<strong>Alpha Blend</strong>シェーダーを作成するだけです。<br>
    - クリッピングメッシュがない場合は、クリッピングシェーダを作成する必要はありません。<br>
    - クリッピングマスクを作る<strong>Alpha Mask</strong>シェーダは固定された役割のみを行うので、カスタムシェーダで制作する必要はありません。<br>
    </p>
    <br>
    
    <p>
    このページでは、デフォルトの「Gamma Space」で「Alpha Blend」シェーダを作成するための規則と方法について最初に説明します。<br>
    そして、シェーダを決定する要因に応じて修正する必要がある部分をそれぞれ説明します。<br>
    </p>
    <br>
    
    <p>
    AnyPortraitパッケージに組み込まれているシェーダコードを確認しておくと便利です。<br>
    シェーダーアセットはデフォルトで「<strong>Assets/AnyPortrait/Assets/Shaders</strong>」にあります。<br>
    提供されるシェーダを複製して必要な部分を修正すると便利です。<br>
    </p>
    <br>
    
    <!-- 12. 참고 박스 시작 -->
    <div class="alert alert-info" role="alert">
    
    <!-- 3. 서브 타이틀(참고 박스) -->
    <h4>シェーダーグラフで作成する場合</h4>
    <br>
    
    <p>
    シェーダグラフでカスタムシェーダを作成したい場合は、このページで説明するルールをシェーダグラフの形式で作成します。<br>
    詳細については、<a href="../../jp/AdvancedManual/AD_ShaderGraph.html">関連ページ</a>をご覧ください。<br>
    </p>
    <br>
    
    </div>
    <br>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>基本シェーダの作成方法</h3>
    <br>
    
    <p>
    AnyPortraitのデフォルトシェーダは、UnityのデフォルトのTransparentシェーダとは大きく変わりません。<br>
    次のコードは「Gamma Space」の「Alpha Blend」の基本シェーダであり、これを元にカスタムコードを追加すればよいでしょう。<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>メモ</strong></span><br>
    AnyPortraitは「<strong>Surface Shader</strong>」と「<strong>Fragment Shader</strong>」と「<strong>シェーダーグラフ」</strong>の両方をサポートしています。<br>
    このページでは「<strong>Fragment Shader</strong>」のコードに基づいて説明し、ここで説明するルールを状況に合わせて適切に適用すればよいでしょう。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"Sample Shader/Gamma Space - Normal - AlphaBlend"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;<strong>_Color</strong> (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;<strong>_MainTex</strong> (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = <span class="text-danger">"white"</span> {}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger"><strong>"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</strong></span> }<br>
    &emsp;&emsp;&emsp;&emsp;<strong>Blend SrcAlpha OneMinusSrcAlpha</strong><br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger"><strong>"LightMode" = "ForwardBase"</strong></span> }<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>ZWrite Off</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> <strong>_MainTex</strong>;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> <strong>_MainTex_ST</strong>;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> <strong>_Color</strong>;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>col.rgb *= _Color.rgb * 2.0f;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>col.a *= _Color.a;</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>return col;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger"><strong>"LightMode" = "ShadowCaster"</strong></span> }<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>ZWrite On</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma multi_compile_shadowcaster<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{ <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;V2F_SHADOW_CASTER;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert(<span class="text-primary">appdata_base</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> frag(<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>col.a *= _Color.a;</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>if(col.a < 0.05f)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>{</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>discard;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>}</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>SHADOW_CASTER_FRAGMENT(i)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton0" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    シェーダコードの主要部分を見てみましょう。<br>
    </p>
    <br>
    
    <p>
    <strong>1. プロパティ</strong><br>
    <strong>_Color</strong> (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    <strong>_MainTex</strong> (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = <span class="text-danger">"white"</span> {}<br>
    <br>
    Unityのデフォルトの「Transparent」シェーダで使用されるプロパティであり、AnyPortraitで使用されるプロパティです。<br>
    クリッピングされるメッシュではなく一般的な場合は、これらのプロパティのみを使用します。<br>
    したがって、カスタムシェーダでは、これら2つのプロパティに関連するすべてのコードをそのまま作成する必要があります。<br>
    また、AnyPortraitのシステムはこれらのプロパティを制御するため、他のスクリプトでこれらのプロパティを変更しないでください。<br>
    </p>
    <br>
    
    <p>
    <strong>2. 基本パス</strong><br>
    Pass<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;Tags { <span class="text-danger"><strong>"LightMode" = "ForwardBase"</strong></span> }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<strong>ZWrite Off</strong><br>
        ...<br>
    : 基本レンダリングパスのコードです。<br>
    上記のようにパスを明示したのは、影生成のためのパスが別途存在するためです。<br>
    シャドウパスを作成しない場合は、タグ「{ <span class="text-danger"><strong>"LightMode" = "ForwardBase"</strong></span>}」を省略してください。<br>
    「<strong>Z Write</strong>」をしないので、この値を「<strong>Off</strong>」に設定します。<br>
    </p>
    <br>
    
    <p>
    <strong>3. ブレンディング</strong><br>
    <strong>Blend SrcAlpha OneMinusSrcAlpha</strong><br>
    : 「Alpha Blend」シェーダのブレンディングコードです。<br>
    </p>
    <br>
    
    <p>
    <strong>4. 色演算</strong><br>
    <span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <strong>col.rgb *= _Color.rgb * 2.0f;</strong><br>
    <strong>col.a *= _Color.a;</strong><br>
    <strong>return col;</strong><br>
    : AnyPortraitの色演算式は「<strong>2X Multiply</strong>」です。<br>
    したがって、RGBにはさらに2を掛ける必要があります。<br>
    このコードはブレンドによって変わります。<br>
    </p>
    <br>
    
    <p>
    <strong>5. シャドウパス</strong><br>
    Pass<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;Tags { <span class="text-danger"><strong>"LightMode" = "ShadowCaster"</strong></span> }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<strong>ZWrite On</strong><br>
        ...<br>
    }<br>
    : 「Alpha Blend」メッシュの場合は、オプションに応じてシャドウを作成できるはずです。<br>
    したがって、影を生成する「<strong>ShadowCaster</strong>」パスを作成する必要があります。<br>
    このパスはシャドウを生成する役割のみを行うため、上記の例のように作成するだけです。<br>
    「<strong>Surface Shader</strong>」方式で作成する場合は、このパスを作成する必要はありません。<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>「Linear Space」のシェーダー</h3>
    <br>
    
    <p>
    上記の例は「<strong>Gamma Space</strong>」のシェーダーコードです。<br>
    上記の基本コードで、基本パス（「<strong>ForwardBase</strong>」）の「<strong>frag</strong>」関数を次のように修正しましょう。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb *= _Color.rgb * 4.595f;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb = pow(col.rgb, 2.2f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...<br>
    <br>
    </p>
    <button id="scriptcopybutton1" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    「<strong>Linear Space</strong>」では、「<strong>Gamma Space</strong>」と比較して、色に「2.2」の二乗を加えた値が適用されると、元の画像の色に近づいて表示されます。<br>
    そのため、上記のように「<strong>2X Multiply</strong>」演算規則であるにもかかわらず、「2」ではなく「<strong>4.595</strong>」を掛け、最終RGBも「2.2」の二乗をしてくれます。<br>
    この変更点はブレンディングの種類に関係なく適用する必要があります。<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>ブレンディングオプションによるシェーダー</h3>
    <br>
    
    <p>
    メッシュのオプションを変更すると、デフォルトのブレンド「<strong>Alpha Blend</strong>」に加えて、「<strong>Additive</strong>」、「<strong>Soft Additive</strong>」、「<strong>Multiplicative</strong>」の方法でレンダリングできます。<br>
    ブレンディング方式によってシェーダをそれぞれ作成する必要がありますが、上記の「<strong>Alpha Blend</strong>」のコードを少し修正して楽に作成できます。<br>
    「<strong>Alpha Blend</strong>」以外のブレンドオプションは主に「視覚効果」のためであるため、影を生成するパスを作成しないことをお勧めします。<br>
    </p>
    <br>
    
    <p>
    3種類のブレンディングについては、シェーダ内の「<strong>Blend</strong>」と「<strong>frag</strong>」関数の一部のコードを修正すればよい。<br>
    また、「<strong>Alpha Blend</strong>」とは異なり、シャドウ生成パスを省略するので、「<strong>LightMode</strong>」コードを削除するだけです。<br>
    次の例には3つのブレンドのコードがすべて含まれているので、コメントを確認して必要なコードをまとめるだけです。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    &emsp;&emsp;...<br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// --- ブレンディングの種類に応じて選択して作成 ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>Blend One One // Additive</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>Blend OneMinusDstColor One // Soft Additive</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>Blend DstColor SrcColor // Multiplicative</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- パス指定コードの削除 ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>// Tags { "LightMode" = "ForwardBase" }</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>ZWrite Off</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Additive または Soft Additive ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb *= col.a;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// ---------------------------------</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Multiplicative ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb = col.rgb * (col.a) + float4(0.5f, 0.5f, 0.5f, 1.0f) * (1.0f - col.a);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// ----------------------</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>return col;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;<strong>// シャドウ生成パスコードの削除</strong><br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton2" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    <strong>1. ブレンディングオプション</strong><br>
    <span class="text-danger"><strong>Blend One One // Additive</strong></span><br>
    <span class="text-danger"><strong>Blend OneMinusDstColor One // Soft Additive</strong></span><br>
    <span class="text-danger"><strong>Blend DstColor SrcColor // Multiplicative</strong></span><br>
    : メッシュのブレンドオプションに応じて、上記のコードのいずれかを選択できます。<br>
    （シェーダグラフを使用している場合は、「Soft Additive」がサポートされない場合があります。）<br>
    </p>
    <br>
    
    <p>
    <strong>2. マルチパスコードの削除</strong><br>
    <span class="text-danger"><strong>// Tags { "LightMode" = "ForwardBase" }</strong></span><br>
    : 影生成パスがなくなるので、マルチパスに関連するコードは削除してもよい。<br>
    シャドウ生成パスコードも削除します。<br>
    </p>
    <br>
    
    <p>
    <strong>3. 色演算式の修正</strong><br>
    <strong>(1)</strong> Additive, Soft Additive<br>
    <span class="text-danger"><strong>col.rgb *= col.a;</strong></span><br>
    <span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    <br>
    <strong>(2)</strong> Multiplicative<br>
    <span class="text-danger"><strong>col.rgb = col.rgb * (col.a) + float4(0.5f, 0.5f, 0.5f, 1.0f) * (1.0f - col.a);</strong></span><br>
    <span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    <br>
    : ブレンドに合わせて最終的な色を変更し、Alphaの値を1に変更します。<br>
    <strong>Additive</strong>と<strong>Soft Additive</strong>の色演算式は互いに同じです。<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>クリッピングメッシュに適用されるシェーダ</h3>
    <br>
    
    <p>
    クリッピングされるメッシュは別のシェーダによってレンダリングされます。<br>
    クリッピング用シェーダには、クリッピングマスクを生成するメッシュのレンダリング結果をテクスチャ形式で受け取り、一部がレンダリングされないようにする演算が追加されます。<br>
    クリッピング用のプロパティとクリッピング操作を基本シェーダに追加するだけです。<br>
    また、クリッピングシェーダは「<strong>Alpha Blend</strong>」でもシャドウを生成する必要はありませんので、シングルパスでのみ作成してください。<br>
    マスクメッシュの影の中に含まれるからです。<br>
    以下の例は、「<strong>Gamma Space</strong>」の「<strong>Alpha Blend</strong>」の場合のシェーダであり、上記の説明に合わせて変更できます。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"Sample Shader/Gamma Space - Clipped - AlphaBlend"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// --- クリッピングプロパティ ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- クリッピング操作のための「Screen Position」 ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>float4 screenPos : TEXCOORD1;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- クリッピング用のプロパティ変数 ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>sampler2D _MaskTex;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>float4 _MaskScreenSpaceOffset;</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- クリッピング用「Screen Position」の計算 ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>o.screenPos = ComputeScreenPos(o.vertex);</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (v2f i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- クリッピングマスクによるアルファチャンネル演算 ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>float2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV -= float2(0.5f, 0.5f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.x *= _MaskScreenSpaceOffset.z;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.y *= _MaskScreenSpaceOffset.w;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.x += _MaskScreenSpaceOffset.x * _MaskScreenSpaceOffset.z;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.y += _MaskScreenSpaceOffset.y * _MaskScreenSpaceOffset.w;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV += float2(0.5f, 0.5f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.a *= tex2D(_MaskTex, screenUV).r;</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton3" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    <strong>1. プロパティ</strong><br>
    <span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    <span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    : クリッピングマスク処理のために、マスクテクスチャをプロパティに追加します。<br>
    上記のようにプロパティを追加すると、AnyPortraitは自動的にクリッピングレンダリングを処理します。<br>
    「<strong>_MaskScreenSpaceOffset</strong>」は、クリッピングマスクを「画面座標系（Screen Space）」を基準に適用するためのプロパティです。<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>sampler2D _MaskTex;</strong></span><br>
    <span class="text-danger"><strong>float4 _MaskScreenSpaceOffset;</strong></span><br>
    : 追加されたプロパティに合わせて変数も追加する必要があります。<br>
    </p>
    <br>
    
    <p>
    <strong>2. Screen Space Position</strong><br>
    <span class="text-danger"><strong>float4 screenPos : TEXCOORD1;</strong></span><br>
    : クリッピングマスクは画面座標系で処理されます。<br>
    したがって、頂点の画面座標系の位置を頂点シェーダで計算し、フラグメントシェーダに渡す必要があります。<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>o.screenPos = ComputeScreenPos(o.vertex);</strong></span><br>
    : 頂点シェーダで画面座標系の位置を計算するコードを追加します。<br>
    </p>
    <br>
    
    <p>
    <strong>3. マスクによるアルファチャンネル値の計算</strong><br>
    <span class="text-danger"><strong>float2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);</strong></span><br>
    <span class="text-danger"><strong>screenUV -= float2(0.5f, 0.5f);</strong></span><br>
    <span class="text-danger"><strong>screenUV.x *= _MaskScreenSpaceOffset.z;</strong></span><br>
    <span class="text-danger"><strong>screenUV.y *= _MaskScreenSpaceOffset.w;</strong></span><br>
    <span class="text-danger"><strong>screenUV.x += _MaskScreenSpaceOffset.x * _MaskScreenSpaceOffset.z;</strong></span><br>
    <span class="text-danger"><strong>screenUV.y += _MaskScreenSpaceOffset.y * _MaskScreenSpaceOffset.w;</strong></span><br>
    <span class="text-danger"><strong>screenUV += float2(0.5f, 0.5f);</strong></span><br>
    <span class="text-danger"><strong>col.a *= tex2D(_MaskTex, screenUV).r;</strong></span><br>
    : クリッピングマスクを計算してアルファチャンネルに適用する式です。<br>
    AnyPortrait システムで使用する固有の演算式ですのでそのまま作成してください。<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>v16マテリアルセットのクリッピングシェーダとアルファマスクシェーダ</h3>
    <br>
    
    <!-- 4. 버전 설명 -->
    <h4><span class="badge badge-secondary">1.6.0</span></h4>
    
    <p>
    「<strong>AnyPortrait v1.6.0</strong>」では、「マスク」機能が大幅に改善されました。<br>
    追加されたマスク機能をサポートするには、クリッピングシェーダーとアルファマスクシェーダーを変更する必要があります。<br>
    マスク機能については、<a href="../../jp/AdvancedManual/AD_Mask.html">関連ページ</a>を参照してください。<br>
    「<strong>AnyPortrait v1.6.0</strong>」以降、デフォルトで提供されている「v16マテリアルセット」は、以前のバージョンと比較してクリッピング関連のコードが大幅に変更されました。<br>
    「v16 マテリアルセット」の「クリッピングシェーダー」と「アルファマスクシェーダー」のコードを確認し、カスタムシェーダーを作成する際に活用してみてください。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"AnyPortrait/Unlit (v16)/AlphaBlend Clipped"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// 基本クリッピングプロパティ</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio</strong></span> (<span class="text-danger">"Mask Ratio"</span>, Range(0, 1)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// 4つのマスクチャンネル</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_1</strong></span> (<span class="text-danger">"Mask Ratio Ch1"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_1</strong></span> (<span class="text-danger">"Mask Texture Ch1"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_1</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch1"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_1</strong></span> (<span class="text-danger">"Mask Operation Ch1"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_2</strong></span> (<span class="text-danger">"Mask Ratio Ch2"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_2</strong></span> (<span class="text-danger">"Mask Texture Ch2"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_2</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch2"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_2</strong></span> (<span class="text-danger">"Mask Operation Ch2"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_3</strong></span> (<span class="text-danger">"Mask Ratio Ch3"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_3</strong></span> (<span class="text-danger">"Mask Texture Ch3"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_3</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch3"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_3</strong></span> (<span class="text-danger">"Mask Operation Ch3"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_4</strong></span> (<span class="text-danger">"Mask Ratio Ch4"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_4</strong></span> (<span class="text-danger">"Mask Texture Ch4"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_4</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch4"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_4</strong></span> (<span class="text-danger">"Mask Operation Ch4"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// See-Through効果</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughRatio</strong></span> (<span class="text-danger">"See-Through Ratio"</span>, Range(0, 1)) = 0.0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughTex</strong></span> (<span class="text-danger">"See-Through Texture"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughScreenSpaceOffset</strong></span> (<span class="text-danger">"See-Through Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughAlpha</strong></span> (<span class="text-danger">"See-Through Alpha"</span>, Range(0, 1)) = 0.0<br>
    &emsp;&emsp;}<br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags{ <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// クリッピング操作のための「Screen Position」</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> screenPos : TEXCOORD1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// デフォルトのクリッピングプロパティ変数</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 4つのマスクチャネルプロパティ変数</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_1;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_2;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_3;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_4;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 「See-Through」プロパティ変数</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _SeeThroughRatio;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _SeeThroughTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _SeeThroughScreenSpaceOffset;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _SeeThroughAlpha;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数：クリッピングマスクアルファを計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlpha</strong> (<span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数: 演算子によるチャネル別マスクの計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlphaByOp</strong> (<span class="text-primary">float</span> prevMask, <span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio, <span class="text-primary">float</span> op)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> inverseAlpha = 1.0f - alpha;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_And = saturate(prevMask * alpha);//Multiply<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数：マスクレンダリングテクスチャのUVを計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> <strong>GetMaskScreenUV</strong> (<span class="text-primary">float2</span> screenUV, <span class="text-primary">float4</span> offset)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> result = screenUV - <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x *= offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y *= offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x += offset.x * offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y += offset.y * offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result += <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return result;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数：「See-Through」効果を計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half3</span> <strong>GetSeeThroughColor</strong> (<span class="text-primary">half3</span> mainColor, <span class="text-primary">half4</span> seeThroughColor)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> stAlpha = saturate(seeThroughColor.a * _SeeThroughAlpha * _SeeThroughRatio);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return (mainColor * (1.0f - stAlpha)) + (seeThroughColor.rgb * stAlpha);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// クリッピング用のScreen Positionの計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.screenPos = ComputeScreenPos(o.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// クリッピングマスクのための「Screen Position」</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 「See-Through」効果</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> seeThroughColor = tex2D(_SeeThroughTex, GetMaskScreenUV(screenUV, _SeeThroughScreenSpaceOffset));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb = GetSeeThroughColor(col.rgb, seeThroughColor);<br>
    <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    #if UNITY_COLORSPACE_GAMMA<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 色演算 (Gamma Space)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    #else<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 色演算 (Linear Space)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 4.595f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb = pow(col.rgb, 2.2f);<br>
    #endif<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// アルファマスク計算コード</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;float maskResult = 1.0f;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 1. クリッピングマスク</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 2. 4つのチャンネル別マスク</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= maskResult;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;(Shadow Caster Passは省略)<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton4" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    上記のシェーダは、「v16 マテリアルセット」に含まれるクリッピングシェーダの基本コードです。<br>
    以前に比べてマスク関連のプロパティが多く追加されました。<br>
    また、影を生成する「パス」が追加されました。<br>
    （ただし、ここでは「シャドウ生成パス」の説明は省略します。）<br>
    </p>
    <br>
    
    <p>
    <strong>1. プロパティ</strong><br>
    <span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    <span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    <span class="text-danger"><strong>_MaskRatio</strong></span> (<span class="text-danger">"Mask Ratio"</span>, Range(0, 1)) = 0<br>
    <span class="text-danger"><strong>_MaskRatio_1</strong></span> (<span class="text-danger">"Mask Ratio Ch1"</span>, Range(0, 1)) = 0<br>
    <span class="text-danger"><strong>_MaskTex_1</strong></span> (<span class="text-danger">"Mask Texture Ch1"</span>, 2D) = "black" {}<br>
    <span class="text-danger"><strong>_MaskScreenSpaceOffset_1</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch1"</span>, Vector) = (0, 0, 0, 1)<br>
    <span class="text-danger"><strong>_MaskOp_1</strong></span> (<span class="text-danger">"Mask Operation Ch1"</span>, Range(0, 3)) = 0<br>
    : アルファマスク操作のプロパティが以前のバージョンと比較して増加しました。<br>
    既存と同じ「<strong>_MaskTex</strong>」、「<strong>_MaskScreenSpaceOffset</strong>」に加えて、該当チャンネル（クリッピングと4つの追加チャンネル）のマスクを使用するかどうかを決定する「<strong>_MaskRatio</strong>」プロパティーが追加されました。<br>
    また、4つのチャンネルには演算オプションが追加され、「AND」、「OR」などのマスクの組み合わせが可能になりました。<br>
    このための「<strong>_MaskOp_n</strong>」プロパティに関連するコードも確認してください。<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>_SeeThroughRatio</strong></span> (<span class="text-danger">"See-Through Ratio"</span>, Range(0, 1)) = 0.0<br>
    <span class="text-danger"><strong>_SeeThroughTex</strong></span> (<span class="text-danger">"See-Through Texture"</span>, 2D) = "black" {}<br>
    <span class="text-danger"><strong>_SeeThroughScreenSpaceOffset</strong></span> (<span class="text-danger">"See-Through Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    <span class="text-danger"><strong>_SeeThroughAlpha</strong></span> (<span class="text-danger">"See-Through Alpha"</span>, Range(0, 1)) = 0.0<br>
    : 「See-Through」機能が追加されました。<br>
    アルファマスクと似ていますが、RGBAチャネルをすべて使用し、RGBチャネル値に重なる特性があります。<br>
    </p>
    <br>
    
    <p>
    <strong>2. マスク演算関数</strong><br>
    <span class="text-primary">half</span> <strong>GetMaskAlpha</strong> (<span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio)<br>
    : クリッピングマスクを操作する関数です。<br>
    「_MaskRatio」に従って「Alpha」の適用度合いを調整します。<br>
    </p>
    <br>
    
    <p>
    <span class="text-primary">half</span> <strong>GetMaskAlphaByOp</strong> (<span class="text-primary">float</span> prevMask, <span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio, <span class="text-primary">float</span> op)<br>
    : 4つのチャンネルごとのマスクを演算する関数です。<br>
    演算オプションによって異なる式が適用されます。<br>
    </p>
    <br>
    
    <p>
    <span class="text-primary">float2</span> <strong>GetMaskScreenUV</strong> (<span class="text-primary">float2</span> screenUV, <span class="text-primary">float4</span> offset)<br>
    : 「Screen Space」を活用するマスクを参照するためにUV演算を行う関数です。<br>
    マスクごとに個別のUV最適化値（MaskScreenSpaceOffset）があるため、この関数を使用してUVを変換する必要があります。<br>
    </p>
    <br>
    
    <p>
    <span class="text-primary">half3</span> <strong>GetSeeThroughColor</strong> (<span class="text-primary">half3</span> mainColor, <span class="text-primary">half4</span> seeThroughColor)<br>
    : 「See-Through」効果を計算する関数です。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"AnyPortrait/Unlit (v16)/AlphaMask"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// マスクチェーンによるクリッピングプロパティ</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio</strong></span> (<span class="text-danger">"Mask Ratio"</span>, Range(0, 1)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// マスクチェーンによる4つのマスクチャンネル</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_1</strong></span> (<span class="text-danger">"Mask Ratio Ch1"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_1</strong></span> (<span class="text-danger">"Mask Texture Ch1"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_1</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch1"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_1</strong></span> (<span class="text-danger">"Mask Operation Ch1"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_2</strong></span> (<span class="text-danger">"Mask Ratio Ch2"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_2</strong></span> (<span class="text-danger">"Mask Texture Ch2"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_2</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch2"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_2</strong></span> (<span class="text-danger">"Mask Operation Ch2"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_3</strong></span> (<span class="text-danger">"Mask Ratio Ch3"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_3</strong></span> (<span class="text-danger">"Mask Texture Ch3"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_3</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch3"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_3</strong></span> (<span class="text-danger">"Mask Operation Ch3"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_4</strong></span> (<span class="text-danger">"Mask Ratio Ch4"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_4</strong></span> (<span class="text-danger">"Mask Texture Ch4"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_4</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch4"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_4</strong></span> (<span class="text-danger">"Mask Operation Ch4"</span>, Range(0, 3)) = 0<br>
    &emsp;&emsp;}<br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType"="Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;Cull Off<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// クリッピング操作のための「Screen Position」</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> screenPos : TEXCOORD1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// デフォルトのクリッピングプロパティ変数</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 4つのマスクチャネルプロパティ変数</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_1;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_2;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_3;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_4;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数：クリッピングマスクアルファ計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlpha</strong> (<span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数：演算子によるチャネル別マスクの計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlphaByOp</strong> (<span class="text-primary">float</span> prevMask, <span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio, <span class="text-primary">float</span> op)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> inverseAlpha = 1.0f - alpha;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_And = saturate(prevMask * alpha);//Multiply<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスク関数：マスクレンダリングテクスチャのUVを計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> <strong>GetMaskScreenUV</strong> (<span class="text-primary">float2</span> screenUV, <span class="text-primary">float4</span> offset)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> result = screenUV - <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x *= offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y *= offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x += offset.x * offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y += offset.y * offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result += <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return result;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// クリッピング用「Screen Position」の計算</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.screenPos = ComputeScreenPos(o.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb = fixed3(1.0f, 1.0f, 1.0f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a = saturate(col.a * _Color.a);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// マスクチェーンのためのマスク操作</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskResult = 1.0f;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 1. クリッピングマスク</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 2. 4つのチャンネル別マスク</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= maskResult;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton5" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    上記のシェーダは、「v16マテリアルセット」のアルファマスクシェーダの基本コードです。<br>
    従来は単に白に「Alpha」チャンネルのみ演算する役割だけを行いましたが、「AnyPortrait v1.6.0」ではマスク関連コードが追加されました。<br>
    これは「マスクチェーン」機能をサポートするためです。 （<a href="../../jp/AdvancedManual/AD_MaskChain.html">関連ページ</a>）<br>
    クリッピング関連コードはクリッピングシェーダと同じですが、「Alpha」チャンネルとは無関係の「See-Through」効果はこのシェーダから除外されます。<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>キーワードを使用する場合</h3>
    <br>
    
    <p>
    「キーワード」を使用して、1つのシェーダコードを複数のバージョンにコンパイルするようにして利用できます。<br>
    「AnyPortrait v1.5.1」に追加された機能を利用して、シェーダのキーワードを利用できます。<br>
    キーワードについては、次の Unity 公式文書に関する情報をご覧いただけます。<br>
    - <a href="https://docs.unity3d.com/ja/current/Manual/SL-MultipleProgramVariants.html" target="_sub">Unityのマニュアル</a><br>
    </p>
    <br>
    
    <p>
    以下は、「<strong>SPECIAL_COLOR</strong>」というキーワードによって色演算が変わるシェーダの例です。<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"Shader Example/Gamma Space - Normal - AlphaBlend (Keyword)"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>#pragma multi_compile __ SPECIAL_COLOR</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>#ifdef SPECIAL_COLOR</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb *= fixed3(0.0f, 1.0f, 0.0f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>#endif</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton6" class="btn btn-info float-right">クリップボードにコピー</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    <strong>1. キーワード宣言</strong><br>
    <span class="text-danger"><strong>#pragma multi_compile __ SPECIAL_COLOR</strong></span><br>
    : 「<strong>#pragma multi_compile</strong>」構文を使用してキーワードを宣言します。<br>
    この例では、「<strong>SPECIAL_COLOR</strong>」というキーワードを新しく宣言しました。<br>
    Unityでシェーダバリアントを生成する「<strong>multi_compile</strong>」と「<strong>shader_feature</strong>」ディレクティブを使用するか、動的ブランチを生成する「<strong>dynamic_branch</strong>」ディレクティブを使用してキーワードを利用できます。<br>
    ただし、AnyPortraitはマテリアルを動的に生成するため、アセットベースでシェーダバリアントをコンパイルする「<strong>shader_feature</strong>」は利用できません。<br>
    </p>
    <br>
    
    <p>
    <strong>2. コード分​​岐の作成</strong><br>
    <span class="text-danger"><strong>#ifdef SPECIAL_COLOR</strong></span><br>
    <span class="text-danger"><strong>col.rgb *= fixed3(0.0f, 1.0f, 0.0f);</strong></span><br>
    <span class="text-danger"><strong>#endif</strong></span><br>
    : キーワードによって異なる動作をするように作成します。<br>
    「<strong>multi_compile</strong>」を使用した場合は「#ifdef、#else、#elif、#endif」ディレクティブを使用し、「<strong>dynamic_branch</strong>」を使用した場合は「if（）」文を使用します。<br>
    この例では、キーワード「<strong>SPECIAL_COLOR</strong>」が有効な場合、緑色のチャンネルの色のみをレンダリングするように作成しました。<br>
    </p>
    <br>
    
    <p>
    キーワードを使用するには、「マテリアルライブラリ」で設定する必要があります。<br>
    詳細は<a href="../../jp/AdvancedManual/AD_MaterialLibrary.html">関連ページ</a>で確認できます。<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_2055.jpg"/>
    <br>
    
    <p>
    <strong>(1)</strong> マテリアルライブラリを開きます。<br>
    <strong>(2)</strong> 「<strong>SPECIAL_COLOR</strong>」という名前のプロパティオプションを追加し、「<strong>Keyword</strong>」タイプに設定してから「<strong>Enable</strong>」に設定します。<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_2056.jpg"/>
    <br>
    
    <p>
    「Bake」をして実行すると、上記のようにキーワードが有効かどうかによってレンダリング結果が変わることがわかります。<br>
    </p>
    <br>
    
    <!-- 5. 바닥 네비바 -->
    <br>
    <br>
    <br>
    <br>
    <nav class="navbar fixed-bottom navbar-light bg-light">
        <a class="btn btn-light" role="button" href="../../jp/Script/SC_Physics.html">< 物理効果</a>
        <a class="btn btn-light" role="button" href="../../jp/Script/SC_Timeline.html">タイムライン ></a>
    </nav>
    
    <!-- 페이지 내용 끝! -->

    
    <!-- 종료 -->
    </div>

    <!-- 부트스트랩 -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script type="text/javascript" src="../../js/bootstrap.js"></script>
    <!--------------->

    <!-- 클립보드 스크립트 -->
    <script>
    document.getElementById("scriptcopybutton0").addEventListener("click", function() {
    const textToCopy = "Shader \"Sample Shader/Gamma Space - Normal - AlphaBlend\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\t}\n\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tTags { \"LightMode\" = \"ForwardBase\" }\n\t\t\tZWrite Off\n\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\t\t\t\t\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\n\t\tPass\n\t\t{\n\t\t\tTags { \"LightMode\" = \"ShadowCaster\" }\n\t\t\tZWrite On\n\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t#pragma multi_compile_shadowcaster\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{ \n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tV2F_SHADOW_CASTER;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\tv2f vert(appdata_base v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\tTRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n\t\t\t\to.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfloat4 frag(v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\tif(col.a < 0.05f)\n\t\t\t\t{\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tSHADOW_CASTER_FRAGMENT(i)\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton1").addEventListener("click", function() {
    const textToCopy = "\t\t\t...\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 4.595f;\n\t\t\t\tcol.rgb = pow(col.rgb, 2.2f);\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\t...\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton2").addEventListener("click", function() {
    const textToCopy = "\t...\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\n\t\t// --- ブレンディングの種類に応じて選択して作成 ---\n\t\tBlend One One // Additive\n\t\tBlend OneMinusDstColor One // Soft Additive\n\t\tBlend DstColor SrcColor // Multiplicative\n\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\t// --- パス指定コードの削除 ---\n\t\t\t// Tags { \"LightMode\" = \"ForwardBase\" }\n\t\t\tZWrite Off\n\n\t\t\tCGPROGRAM\n\t\t\t...\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t// --- Additive または Soft Additive ---\n\t\t\t\tcol.rgb *= col.a;\n\t\t\t\tcol.a = 1.0f;\n\t\t\t\t// ---------------------------------\n\n\t\t\t\t// --- Multiplicative ---\n\t\t\t\tcol.rgb = col.rgb * (col.a) + float4(0.5f, 0.5f, 0.5f, 1.0f) * (1.0f - col.a);\n\t\t\t\tcol.a = 1.0f;\n\t\t\t\t// ----------------------\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t\t// シャドウ生成パスコードの削除\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton3").addEventListener("click", function() {
    const textToCopy = "Shader \"Sample Shader/Gamma Space - Clipped - AlphaBlend\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\n\t\t// --- クリッピングプロパティ ---\n\t\t_MaskTex (\"Mask Texture (A)\", 2D) = \"white\" {}\n\t\t_MaskScreenSpaceOffset (\"Mask Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t}\n\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tZWrite Off\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\n\t\t\t\t// --- クリッピング操作のための「Screen Position」 ---\n\t\t\t\tfloat4 screenPos : TEXCOORD1;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\t// --- クリッピング用のプロパティ変数 ---\n\t\t\tsampler2D _MaskTex;\n\t\t\tfloat4 _MaskScreenSpaceOffset;\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\n\t\t\t\t// --- クリッピング用「Screen Position」の計算 ---\n\t\t\t\to.screenPos = ComputeScreenPos(o.vertex);\n\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t// --- クリッピングマスクによるアルファチャンネル演算 ---\n\t\t\t\tfloat2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);\n\t\t\t\tscreenUV -= float2(0.5f, 0.5f);\n\t\t\t\tscreenUV.x *= _MaskScreenSpaceOffset.z;\n\t\t\t\tscreenUV.y *= _MaskScreenSpaceOffset.w;\n\t\t\t\tscreenUV.x += _MaskScreenSpaceOffset.x * _MaskScreenSpaceOffset.z;\n\t\t\t\tscreenUV.y += _MaskScreenSpaceOffset.y * _MaskScreenSpaceOffset.w;\n\t\t\t\tscreenUV += float2(0.5f, 0.5f);\n\t\t\t\tcol.a *= tex2D(_MaskTex, screenUV).r;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton4").addEventListener("click", function() {
    const textToCopy = "Shader \"AnyPortrait/Unlit (v16)/AlphaBlend Clipped\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\n\t\t// 基本クリッピングプロパティ\n\t\t_MaskTex (\"Mask Texture (A)\", 2D) = \"white\" {}\n\t\t_MaskScreenSpaceOffset (\"Mask Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t\t_MaskRatio (\"Mask Ratio\", Range(0, 1)) = 0\n\n\t\t// 4つのマスクチャンネル\n\t\t_MaskRatio_1 (\"Mask Ratio Ch1\", Range(0, 1)) = 0\n\t\t_MaskTex_1 (\"Mask Texture Ch1\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_1 (\"Mask Screen Space Offset Ch1\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_1 (\"Mask Operation Ch1\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_2 (\"Mask Ratio Ch2\", Range(0, 1)) = 0\n\t\t_MaskTex_2 (\"Mask Texture Ch2\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_2 (\"Mask Screen Space Offset Ch2\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_2 (\"Mask Operation Ch2\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_3 (\"Mask Ratio Ch3\", Range(0, 1)) = 0\n\t\t_MaskTex_3 (\"Mask Texture Ch3\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_3 (\"Mask Screen Space Offset Ch3\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_3 (\"Mask Operation Ch3\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_4 (\"Mask Ratio Ch4\", Range(0, 1)) = 0\n\t\t_MaskTex_4 (\"Mask Texture Ch4\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_4 (\"Mask Screen Space Offset Ch4\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_4 (\"Mask Operation Ch4\", Range(0, 3)) = 0\n\n\t\t// See-Through効果\n\t\t_SeeThroughRatio (\"See-Through Ratio\", Range(0, 1)) = 0.0\n\t\t_SeeThroughTex (\"See-Through Texture\", 2D) = \"black\" {}\n\t\t_SeeThroughScreenSpaceOffset (\"See-Through Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t\t_SeeThroughAlpha (\"See-Through Alpha\", Range(0, 1)) = 0.0\n\t}\n\tSubShader\n\t{\n\t\tTags{ \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tZWrite Off\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\n\t\t\t\t// クリッピング操作のための「Screen Position」\n\t\t\t\tfloat4 screenPos : TEXCOORD1;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\t// デフォルトのクリッピングプロパティ変数\n\t\t\tsampler2D _MaskTex;\n\t\t\tfloat4 _MaskScreenSpaceOffset;\n\t\t\tfloat _MaskRatio;\n\n\t\t\t// 4つのマスクチャネルプロパティ変数\n\t\t\tfloat _MaskRatio_1;\n\t\t\tsampler2D _MaskTex_1;\n\t\t\tfloat4 _MaskScreenSpaceOffset_1;\n\t\t\tfloat _MaskOp_1;\n\n\t\t\tfloat _MaskRatio_2;\n\t\t\tsampler2D _MaskTex_2;\n\t\t\tfloat4 _MaskScreenSpaceOffset_2;\n\t\t\tfloat _MaskOp_2;\n\n\t\t\tfloat _MaskRatio_3;\n\t\t\tsampler2D _MaskTex_3;\n\t\t\tfloat4 _MaskScreenSpaceOffset_3;\n\t\t\tfloat _MaskOp_3;\n\n\t\t\tfloat _MaskRatio_4;\n\t\t\tsampler2D _MaskTex_4;\n\t\t\tfloat4 _MaskScreenSpaceOffset_4;\n\t\t\tfloat _MaskOp_4;\n\n\t\t\t// 「See-Through」プロパティ変数\n\t\t\tfloat _SeeThroughRatio;\n\t\t\tsampler2D _SeeThroughTex;\n\t\t\tfloat4 _SeeThroughScreenSpaceOffset;\n\t\t\tfloat _SeeThroughAlpha;\n\n\t\t\t// マスク関数：クリッピングマスクアルファを計算\n\t\t\thalf GetMaskAlpha (float alpha, float ratio)\n\t\t\t{\n\t\t\t\treturn saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// マスク関数: 演算子によるチャネル別マスクの計算\n\t\t\thalf GetMaskAlphaByOp (float prevMask, float alpha, float ratio, float op)\n\t\t\t{\n\t\t\t\tfloat opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND\n\t\t\t\tfloat opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR\n\t\t\t\tfloat opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND\n\t\t\t\tfloat opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR\n\n\t\t\t\tfloat inverseAlpha = 1.0f - alpha;\n\n\t\t\t\tfloat nextAlpha_And = saturate(prevMask * alpha);//Multiply\n\t\t\t\tfloat nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended\n\t\t\t\tfloat nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)\n\t\t\t\tfloat nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)\n\n\t\t\t\tfloat resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);\n\n\t\t\t\treturn saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// マスク関数：マスクレンダリングテクスチャのUVを計算\n\t\t\tfloat2 GetMaskScreenUV (float2 screenUV, float4 offset)\n\t\t\t{\n\t\t\t\tfloat2 result = screenUV - float2(0.5f, 0.5f);\n\t\t\t\tresult.x *= offset.z;\n\t\t\t\tresult.y *= offset.w;\n\t\t\t\tresult.x += offset.x * offset.z;\n\t\t\t\tresult.y += offset.y * offset.w;\n\t\t\t\tresult += float2(0.5f, 0.5f);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// マスク関数：「See-Through」効果を計算\n\t\t\thalf3 GetSeeThroughColor (half3 mainColor, half4 seeThroughColor)\n\t\t\t{\n\t\t\t\tfloat stAlpha = saturate(seeThroughColor.a * _SeeThroughAlpha * _SeeThroughRatio);\n\t\t\t\treturn (mainColor * (1.0f - stAlpha)) + (seeThroughColor.rgb * stAlpha);\n\t\t\t}\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\n\t\t\t\t// クリッピング用のScreen Positionの計算\n\t\t\t\to.screenPos = ComputeScreenPos(o.vertex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\t// クリッピングマスクのための「Screen Position」\n\t\t\t\tfloat2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);\n\n\t\t\t\t// 「See-Through」効果\n\t\t\t\thalf4 seeThroughColor = tex2D(_SeeThroughTex, GetMaskScreenUV(screenUV, _SeeThroughScreenSpaceOffset));\n\t\t\t\tcol.rgb = GetSeeThroughColor(col.rgb, seeThroughColor);\n\n\t\t\t\t\n#if UNITY_COLORSPACE_GAMMA\n\t\t\t\t// 色演算 (Gamma Space)\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n#else\n\t\t\t\t// 色演算 (Linear Space)\n\t\t\t\tcol.rgb *= _Color.rgb * 4.595f;\n\t\t\t\tcol.rgb = pow(col.rgb, 2.2f);\n#endif\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t// アルファマスク計算コード\n\t\t\t\tfloat maskResult = 1.0f;\n\n\t\t\t\t// 1. クリッピングマスク\n\t\t\t\thalf maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;\n\t\t\t\tmaskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));\n\n\t\t\t\t// 2. 4つのチャンネル別マスク\n\t\t\t\tfloat maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;\n\t\t\t\tfloat maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;\n\t\t\t\tfloat maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;\n\t\t\t\tfloat maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;\n\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);\n\n\t\t\t\tcol.a *= maskResult;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t(Shadow Caster Passは省略)\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton5").addEventListener("click", function() {
    const textToCopy = "Shader \"AnyPortrait/Unlit (v16)/AlphaMask\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\n\t\t// マスクチェーンによるクリッピングプロパティ\n\t\t_MaskTex (\"Mask Texture (A)\", 2D) = \"white\" {}\n\t\t_MaskScreenSpaceOffset (\"Mask Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t\t_MaskRatio (\"Mask Ratio\", Range(0, 1)) = 0\n\n\t\t// マスクチェーンによる4つのマスクチャンネル\n\t\t_MaskRatio_1 (\"Mask Ratio Ch1\", Range(0, 1)) = 0\n\t\t_MaskTex_1 (\"Mask Texture Ch1\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_1 (\"Mask Screen Space Offset Ch1\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_1 (\"Mask Operation Ch1\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_2 (\"Mask Ratio Ch2\", Range(0, 1)) = 0\n\t\t_MaskTex_2 (\"Mask Texture Ch2\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_2 (\"Mask Screen Space Offset Ch2\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_2 (\"Mask Operation Ch2\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_3 (\"Mask Ratio Ch3\", Range(0, 1)) = 0\n\t\t_MaskTex_3 (\"Mask Texture Ch3\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_3 (\"Mask Screen Space Offset Ch3\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_3 (\"Mask Operation Ch3\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_4 (\"Mask Ratio Ch4\", Range(0, 1)) = 0\n\t\t_MaskTex_4 (\"Mask Texture Ch4\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_4 (\"Mask Screen Space Offset Ch4\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_4 (\"Mask Operation Ch4\", Range(0, 3)) = 0\n\t}\n\tSubShader\n\t{\n\t\tTags { \"RenderType\"=\"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tZWrite Off\n\t\tCull Off\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\n\t\t\t\t// クリッピング操作のための「Screen Position」\n\t\t\t\tfloat4 screenPos : TEXCOORD1;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\t// デフォルトのクリッピングプロパティ変数\n\t\t\tsampler2D _MaskTex;\n\t\t\tfloat4 _MaskScreenSpaceOffset;\n\t\t\tfloat _MaskRatio;\n\n\t\t\t// 4つのマスクチャネルプロパティ変数\n\t\t\tfloat _MaskRatio_1;\n\t\t\tsampler2D _MaskTex_1;\n\t\t\tfloat4 _MaskScreenSpaceOffset_1;\n\t\t\tfloat _MaskOp_1;\n\n\t\t\tfloat _MaskRatio_2;\n\t\t\tsampler2D _MaskTex_2;\n\t\t\tfloat4 _MaskScreenSpaceOffset_2;\n\t\t\tfloat _MaskOp_2;\n\n\t\t\tfloat _MaskRatio_3;\n\t\t\tsampler2D _MaskTex_3;\n\t\t\tfloat4 _MaskScreenSpaceOffset_3;\n\t\t\tfloat _MaskOp_3;\n\n\t\t\tfloat _MaskRatio_4;\n\t\t\tsampler2D _MaskTex_4;\n\t\t\tfloat4 _MaskScreenSpaceOffset_4;\n\t\t\tfloat _MaskOp_4;\n\n\t\t\t// マスク関数：クリッピングマスクアルファ計算\n\t\t\thalf GetMaskAlpha (float alpha, float ratio)\n\t\t\t{\n\t\t\t\treturn saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// マスク関数：演算子によるチャネル別マスクの計算\n\t\t\thalf GetMaskAlphaByOp (float prevMask, float alpha, float ratio, float op)\n\t\t\t{\n\t\t\t\tfloat opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND\n\t\t\t\tfloat opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR\n\t\t\t\tfloat opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND\n\t\t\t\tfloat opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR\n\n\t\t\t\tfloat inverseAlpha = 1.0f - alpha;\n\n\t\t\t\tfloat nextAlpha_And = saturate(prevMask * alpha);//Multiply\n\t\t\t\tfloat nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended\n\t\t\t\tfloat nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)\n\t\t\t\tfloat nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)\n\n\t\t\t\tfloat resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);\n\n\t\t\t\treturn saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// マスク関数：マスクレンダリングテクスチャのUVを計算\n\t\t\tfloat2 GetMaskScreenUV (float2 screenUV, float4 offset)\n\t\t\t{\n\t\t\t\tfloat2 result = screenUV - float2(0.5f, 0.5f);\n\t\t\t\tresult.x *= offset.z;\n\t\t\t\tresult.y *= offset.w;\n\t\t\t\tresult.x += offset.x * offset.z;\n\t\t\t\tresult.y += offset.y * offset.w;\n\t\t\t\tresult += float2(0.5f, 0.5f);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\n\t\t\t\t// クリッピング用「Screen Position」の計算\n\t\t\t\to.screenPos = ComputeScreenPos(o.vertex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb = fixed3(1.0f, 1.0f, 1.0f);\n\t\t\t\tcol.a = saturate(col.a * _Color.a);\n\n\t\t\t\t// マスクチェーンのためのマスク操作\n\t\t\t\tfloat2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);\n\n\t\t\t\tfloat maskResult = 1.0f;\n\n\t\t\t\t// 1. クリッピングマスク\n\t\t\t\thalf maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;\n\t\t\t\tmaskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));\n\n\t\t\t\t// 2. 4つのチャンネル別マスク\n\t\t\t\tfloat maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;\n\t\t\t\tfloat maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;\n\t\t\t\tfloat maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;\n\t\t\t\tfloat maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;\n\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);\n\n\t\t\t\tcol.a *= maskResult;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton6").addEventListener("click", function() {
    const textToCopy = "Shader \"Shader Example/Gamma Space - Normal - AlphaBlend (Keyword)\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\t}\n\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tZWrite Off\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#pragma multi_compile __ SPECIAL_COLOR\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\t\t\t\t\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t#ifdef SPECIAL_COLOR\n\t\t\t\tcol.rgb *= fixed3(0.0f, 1.0f, 0.0f);\n\t\t\t\t#endif\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("スクリプトがクリップボードにコピーされました。");
    }).catch(err => {
        console.error("クリップボードのコピーに失敗しました", err);
    });
    });
    </script>
    

    <!--------------->

    </body>
</html>
