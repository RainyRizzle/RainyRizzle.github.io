<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <!-- 제목 -->
        <title>Custom Shader</title>
        <!-- 파비콘 -->
        <link rel="shortcut icon" href="../../Images/favicon.ico"/>
        <!-- 부트스트랩 -->
        <link rel="stylesheet" href="../../css/bootstrap.css">
        <!--------------->

    </head>

    <body>
        <p>
            <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
            <!--로고 : AnyPortrait 홈페이지로 가야한다. (언어별)-->
            <a class="navbar-brand" href="https://rainyrizzle.com/en/anyportrait-en/">
                <img src="../../Images/AP_Logo.png" width="150" height="30" class="d-inline-block align-top" alt="">
            </a>

            <!--메뉴들 : 현재 페이지의 카테고리에 active 붙인다. (언어별 링크) -->
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarText">
                <ul class="navbar-nav mr-auto">
                <li class="nav-item">
                    <a class="nav-link" href="../../en/GettingStarted.html">Getting Started</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../../en/AdManual.html">Manual</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../en/Script.html">Script</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://rainyrizzle.com/en/ap-video-tutorials-en/">Video</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://rainyrizzle.com/en/forum-en/">Forum</a>
                </li>

                </ul>

                <!-- 언어 변경. 현재 페이지의 주소에서 언어 주소만 변경한다. (해당 언어에 active) -->
                <div class="btn-group mr-2" role="group" aria-label="Basic example">
                    <a role="button" class="btn btn-secondary active" href="../../en/Script/SC_CustomShader.html">EN</a>
                    <a role="button" class="btn btn-secondary" href="../../kr/Script/SC_CustomShader.html">KR</a>
                    <a role="button" class="btn btn-secondary" href="../../jp/Script/SC_CustomShader.html">JP</a>
                </div>

                <!-- 여백 -->
                <p></p>

                <!-- 검색버튼 -->
                <form class="form-inline">
                    <a class="btn btn-light" role="button" href="../../en/Search.html">Search</a>
                </form>
            </div>
        </nav>
    </p>

    <!-- 실제 바디 부분 -->
    <div class="container">
    <br>
    <br>
    <!-- 여기에 내용을 적어주세요 -->

    <!-- 여기서부터 페이지 내용이 작성됩니다. -->
    <!-- 1. 페이지 진입 경로 -->
    <p><a href="https://rainyrizzle.com/en/anyportrait-en/"><span class="text-dark">AnyPortrait</span></a> > <a href="../../en/Script.html"><span class="text-dark">Script</span></a> > Custom Shader</p>
    
    <!-- 2. 페이지 메인 타이틀 -->
    <h1 class="display-5">Custom Shader</h1>
    <br>
    
    <!-- 4. 버전 설명 -->
    <h4><span class="badge badge-secondary">1.6.0</span></h4>
    
    <p>
    AnyPortrait provides a variety of commonly used shaders, but depending on the project, you may need to write a custom shader with special effects.<br>
    You can easily write a custom shader to create great rendering results by following just a few rules of AnyPortrait.<br>
    This page explains how AnyPortrait's shader basics are structured.<br>
    Based on this explanation, we hope you will write and apply a custom shader.<br>
    </p>
    <br>
    
    <p>
    When you want to apply shaders you wrote, you can use the <strong>Material Library</strong> or change the properties of the mesh.<br>
    Please check the following manuals for how to change shaders.<br>
    - <a href="../../en/AdvancedManual/AD_MaterialLibrary.html">Material Library</a><br>
    - <a href="../../en/AdvancedManual/AD_MeshShader.html">Shader for meshes</a><br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>Note</strong></span><br>
    This page does not cover how to write shaders.<br>
    For more information, please refer to the Unity documentation, forums, and related sites!<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>Shaders in AnyPortrait</h3>
    <br>
    
    <p>
    AnyPortrait does not use a single shader, but rather uses a set of shaders that are appropriate for the situation.<br>
    A total of 17 shaders are applied as a set based on three factors from which shaders are derived. (<a href="../../en/AdvancedManual/AD_MaterialLibrary.html">Related page</a>)<br>
    The factors are as follows.<br>
    </p>
    <br>
    
    <p>
    <strong>1. Color Space</strong><br>
    The shader is determined based on the color space of the project.<br>
    It is written based on <strong>Gamma Space</strong>, and the color calculation formula changes in the case of <strong>Linear Space</strong>.<br>
    </p>
    <br>
    
    <p>
    <strong>2. Blending</strong><br>
    Meshes are rendered using one of four blending methods.<br>
    The default is <strong>Alpha Blend</strong>, with <strong>Additive</strong>, <strong>Soft Additive</strong>, and <strong>Multiplicative</strong> slightly modifying the blending properties and the code related to alpha calculations.<br>
    </p>
    <br>
    
    <p>
    <strong>3. Clipping</strong><br>
    The mesh being clipped receives mask texture and performs additional alpha calculations.<br>
    There is also one shader that generates the mask, but it is a functional shader that performs a fixed role.<br>
    </p>
    <br>
    
    <p>
    The above factors are combined to apply a total of 17 shaders to the character.<br>
    However, when you want to write a custom shader, you don't necessarily have to write all of them.<br>
    Just check the following and write only the shaders that fit the situation of your project.<br>
    </p>
    <br>
    
    <p>
    - Write only one type of shader, either <strong>Gamma</strong> or <strong>Linear</strong>, depending on the color space of the project.<br>
    - If you do not use the blending option, you only need to write the <strong>Alpha Blend</strong> shader as default.<br>
    - If there is no clipped mesh, you do not need to write a clipping shader.<br>
    - The <strong>Alpha Mask</strong> shader, which creates a clipping mask, only performs a fixed role, so you do not need to create it as a custom shader.<br>
    </p>
    <br>
    
    <p>
    This page first explains the rules and method for writing an "Alpha Blend" shader in the default "Gamma Space".<br>
    Then it explains the parts that need to be modified depending on the factors that determine the shader.<br>
    </p>
    <br>
    
    <p>
    It might also be helpful to check out the shader codes built into the AnyPortrait package.<br>
    The shader assets are located by default in "<strong>Assets/AnyPortrait/Assets/Shaders</strong>".<br>
    It might be convenient to duplicate the provided shaders and modify the necessary parts.<br>
    </p>
    <br>
    
    <!-- 12. 참고 박스 시작 -->
    <div class="alert alert-info" role="alert">
    
    <!-- 3. 서브 타이틀(참고 박스) -->
    <h4>When creating with Shader Graphs</h4>
    <br>
    
    <p>
    If you want to create a custom shader with Shader Graph, you can write it in the format of a Shader Graph by following the rules described on this page.<br>
    For more information, see the <a href="../../en/AdvancedManual/AD_ShaderGraph.html">Related page</a><br>
    </p>
    <br>
    
    </div>
    <br>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>How to write a basic shader</h3>
    <br>
    
    <p>
    AnyPortrait's default shader is not much different from Unity's default Transparent shader.<br>
    The following code is the default shader for "Alpha Blend" in "Gamma Space", and you can add your own custom code based on it.<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>Note</strong></span><br>
    AnyPortrait supports both <strong>Surface Shader</strong>, <strong>Fragment Shader</strong>, and <strong>Shader Graph</strong>.<br>
    This page explains based on the code of <strong>Fragment Shader</strong>, and you can apply the rules explained here appropriately according to the situation.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"Sample Shader/Gamma Space - Normal - AlphaBlend"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;<strong>_Color</strong> (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;<strong>_MainTex</strong> (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = <span class="text-danger">"white"</span> {}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger"><strong>"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</strong></span> }<br>
    &emsp;&emsp;&emsp;&emsp;<strong>Blend SrcAlpha OneMinusSrcAlpha</strong><br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger"><strong>"LightMode" = "ForwardBase"</strong></span> }<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>ZWrite Off</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> <strong>_MainTex</strong>;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> <strong>_MainTex_ST</strong>;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> <strong>_Color</strong>;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>col.rgb *= _Color.rgb * 2.0f;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>col.a *= _Color.a;</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>return col;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger"><strong>"LightMode" = "ShadowCaster"</strong></span> }<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>ZWrite On</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma multi_compile_shadowcaster<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{ <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;V2F_SHADOW_CASTER;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert(<span class="text-primary">appdata_base</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> frag(<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>col.a *= _Color.a;</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>if(col.a < 0.05f)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>{</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>discard;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>}</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>SHADOW_CASTER_FRAGMENT(i)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton0" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    Let's take a look at the main parts of the shader code.<br>
    </p>
    <br>
    
    <p>
    <strong>1. Properties</strong><br>
    <strong>_Color</strong> (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    <strong>_MainTex</strong> (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = <span class="text-danger">"white"</span> {}<br>
    <br>
    These are the properties used in the default Transparent shader of Unity and the properties used in AnyPortrait.<br>
    In general cases where the mesh is not clipped, only these properties are used.<br>
    Therefore, in custom shaders, all codes related to these two properties must be written as is.<br>
    Also, since the AnyPortrait system controls these properties, you should not modify these properties with other scripts.<br>
    </p>
    <br>
    
    <p>
    <strong>2. Basic Pass</strong><br>
    Pass<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;Tags { <span class="text-danger"><strong>"LightMode" = "ForwardBase"</strong></span> }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<strong>ZWrite Off</strong><br>
        ...<br>
    : Here is the code for the basic rendering pass.<br>
    The basic pass is specified as above because there is a separate pass for shadow casting.<br>
    If you do not write a shadow pass, you can omit the "Tags { <span class="text-danger"><strong>"LightMode" = "ForwardBase"</strong></span> }" part.<br>
    Since we do not do <strong>Z Write</strong>, we set this value to <strong>Off</strong>.<br>
    </p>
    <br>
    
    <p>
    <strong>3. Blending</strong><br>
    <strong>Blend SrcAlpha OneMinusSrcAlpha</strong><br>
    : Blending code for the "Alpha Blend" shader.<br>
    </p>
    <br>
    
    <p>
    <strong>4. Color calculation</strong><br>
    <span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <strong>col.rgb *= _Color.rgb * 2.0f;</strong><br>
    <strong>col.a *= _Color.a;</strong><br>
    <strong>return col;</strong><br>
    : AnyPortrait's color operation formula is "<strong>2X Multiply</strong>".<br>
    So RGB needs to be multiplied by 2 additionally.<br>
    This code changes depending on blending.<br>
    </p>
    <br>
    
    <p>
    <strong>5. Shadow Pass</strong><br>
    Pass<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;Tags { <span class="text-danger"><strong>"LightMode" = "ShadowCaster"</strong></span> }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<strong>ZWrite On</strong><br>
        ...<br>
    }<br>
    : For the "Alpha Blend" mesh, you need to be able to generate shadows depending on the option.<br>
    Therefore, you need to write a "<strong>ShadowCaster</strong>" pass that generates shadows.<br>
    This pass only plays a role in generating shadows, so you can write it as in the example above.<br>
    If you write it in the <strong>Surface Shader</strong> way, you don't need to write this pass.<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>Shaders in Linear Space</h3>
    <br>
    
    <p>
    The above example is shader code in <strong>Gamma Space</strong>, if the color space of the project is <strong>Linear Space</strong>, you need to modify the "<strong>Color calculation</strong>" part.<br>
    In the above basic code, let's modify the <strong>frag</strong> function of the basic pass ("<strong>ForwardBase</strong>") as follows.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb *= _Color.rgb * 4.595f;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb = pow(col.rgb, 2.2f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...<br>
    <br>
    </p>
    <button id="scriptcopybutton1" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    In <strong>Linear Space</strong>, if a value raised to the power of 2.2 is applied to the color compared to <strong>Gamma Space</strong>, it appears closer to the original image color.<br>
    So, even though it is the "<strong>2X Multiply</strong>" operation rule as above, we multiply it by "<strong>4.595</strong>" instead of "2", and the final RGB is also raised to the power of "2.2".<br>
    This change should be applied regardless of the blending type.<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>Shaders based on Blending options</h3>
    <br>
    
    <p>
    By changing the mesh options, you can render in the "<strong>Alpha Blend</strong>", "<strong>Additive</strong>", "<strong>Soft Additive</strong>", and "<strong>Multiplicative</strong>" methods in addition to the default blending method.<br>
    You need to write a shader for each blending method, but you can easily write it by slightly modifying the code of "<strong>Alpha Blend</strong>" above.<br>
    Blending options other than "<strong>Alpha Blend</strong>" are mainly for visual effects, so it is recommended not to write a pass that generates shadows.<br>
    </p>
    <br>
    
    <p>
    For the three types of blending, you just need to modify some codes in the shader, "<strong>Blend</strong>" and "<strong>frag function</strong>".<br>
    Also, unlike <strong>Alpha Blend</strong>, we omit the shadow generation pass, so you can delete the "LightMode" designation code.<br>
    The following example includes the codes for all three types of blending, so you can check the comments and compile the necessary codes.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    &emsp;&emsp;...<br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// --- Select and write according to the blending type ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>Blend One One // Additive</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>Blend OneMinusDstColor One // Soft Additive</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>Blend DstColor SrcColor // Multiplicative</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Delete Pass Tags ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>// Tags { "LightMode" = "ForwardBase" }</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>ZWrite Off</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Additive 또는 Soft Additive ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb *= col.a;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// ---------------------------------</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Multiplicative ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb = col.rgb * (col.a) + float4(0.5f, 0.5f, 0.5f, 1.0f) * (1.0f - col.a);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// ----------------------</strong><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>return col;</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;<strong>// Delete Shadow Generation Pass</strong><br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton2" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    <strong>1. Blending Options</strong><br>
    <span class="text-danger"><strong>Blend One One // Additive</strong></span><br>
    <span class="text-danger"><strong>Blend OneMinusDstColor One // Soft Additive</strong></span><br>
    <span class="text-danger"><strong>Blend DstColor SrcColor // Multiplicative</strong></span><br>
    : Depending on your mesh's blending options, you can choose one of the above codes.<br>
    (Soft Additive may not be supported if you use Shader Graph.)<br>
    </p>
    <br>
    
    <p>
    <strong>2. Delete Multi Pass</strong><br>
    <span class="text-danger"><strong>// Tags { "LightMode" = "ForwardBase" }</strong></span><br>
    : Since the shadow generation pass is gone, you can delete the code related to the multi-pass.<br>
    Also delete the shadow generation pass code.<br>
    </p>
    <br>
    
    <p>
    <strong>3. Modify Color calculation</strong><br>
    <strong>(1)</strong> Additive or Soft Additive<br>
    <span class="text-danger"><strong>col.rgb *= col.a;</strong></span><br>
    <span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    <br>
    <strong>(2)</strong> Multiplicative<br>
    <span class="text-danger"><strong>col.rgb = col.rgb * (col.a) + float4(0.5f, 0.5f, 0.5f, 1.0f) * (1.0f - col.a);</strong></span><br>
    <span class="text-danger"><strong>col.a = 1.0f;</strong></span><br>
    <br>
    : Change the final color to match the blending, and change the Alpha value to 1.<br>
    The color calculation formulas for <strong>Additive</strong> and <strong>Soft Additive</strong> are the same.<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>Shader applied to the Clipped meshes</h3>
    <br>
    
    <p>
    The Clipped meshes are rendered by a separate shader.<br>
    The shader for clipping receives the rendering result of the mesh that creates the clipping mask in texture format and adds an operation to prevent some of it from being rendered.<br>
    You can add the clipping property and the clipping operation to the basic shader.<br>
    Also, the clipping shader does not need to generate shadows in <strong>Alpha Blend</strong>, so you can write it as a single pass.<br>
    This is because it is included in the shadow of the mask mesh.<br>
    The following example is a shader for <strong>Alpha Blend</strong> in <strong>Gamma Space</strong>, and can be modified to match the explanation above.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"Sample Shader/Gamma Space - Clipped - AlphaBlend"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// --- Clipping properties ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Screen Position for Clipping Operations ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>float4 screenPos : TEXCOORD1;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Property variables for Clipping ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>sampler2D _MaskTex;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>float4 _MaskScreenSpaceOffset;</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Calculating Screen Position for Clipping ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>o.screenPos = ComputeScreenPos(o.vertex);</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (v2f i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// --- Set Alpha channel by Clipping mask ---</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>float2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV -= float2(0.5f, 0.5f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.x *= _MaskScreenSpaceOffset.z;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.y *= _MaskScreenSpaceOffset.w;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.x += _MaskScreenSpaceOffset.x * _MaskScreenSpaceOffset.z;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV.y += _MaskScreenSpaceOffset.y * _MaskScreenSpaceOffset.w;</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>screenUV += float2(0.5f, 0.5f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.a *= tex2D(_MaskTex, screenUV).r;</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton3" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    <strong>1. Properties</strong><br>
    <span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    <span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    : Add a mask texture to the property for clipping mask processing.<br>
    If you add a property like the above, AnyPortrait will automatically handle clipping rendering.<br>
    <strong>_MaskScreenSpaceOffset</strong> is a property to apply the clipping mask based on the screen coordinate system.<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>sampler2D _MaskTex;</strong></span><br>
    <span class="text-danger"><strong>float4 _MaskScreenSpaceOffset;</strong></span><br>
    : You also need to add variables to match the added properties.<br>
    </p>
    <br>
    
    <p>
    <strong>2. Screen Space Position Semantic</strong><br>
    <span class="text-danger"><strong>float4 screenPos : TEXCOORD1;</strong></span><br>
    : Clipping masks are processed in screen space.<br>
    Therefore, the position of the vertex in screen space must be calculated in the vertex shader and passed to the fragment shader.<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>o.screenPos = ComputeScreenPos(o.vertex);</strong></span><br>
    : Add code to calculate the position in screen coordinates in the vertex shader.<br>
    </p>
    <br>
    
    <p>
    <strong>3. Setting alpha channel value by mask</strong><br>
    <span class="text-danger"><strong>float2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);</strong></span><br>
    <span class="text-danger"><strong>screenUV -= float2(0.5f, 0.5f);</strong></span><br>
    <span class="text-danger"><strong>screenUV.x *= _MaskScreenSpaceOffset.z;</strong></span><br>
    <span class="text-danger"><strong>screenUV.y *= _MaskScreenSpaceOffset.w;</strong></span><br>
    <span class="text-danger"><strong>screenUV.x += _MaskScreenSpaceOffset.x * _MaskScreenSpaceOffset.z;</strong></span><br>
    <span class="text-danger"><strong>screenUV.y += _MaskScreenSpaceOffset.y * _MaskScreenSpaceOffset.w;</strong></span><br>
    <span class="text-danger"><strong>screenUV += float2(0.5f, 0.5f);</strong></span><br>
    <span class="text-danger"><strong>col.a *= tex2D(_MaskTex, screenUV).r;</strong></span><br>
    : This is the formula for calculating the clipping mask and applying it to the alpha channel.<br>
    Please write it as it is, as it is a unique formula used in the AnyPortrait system.<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>Clipping and Alpha mask shader in v16 material set</h3>
    <br>
    
    <!-- 4. 버전 설명 -->
    <h4><span class="badge badge-secondary">1.6.0</span></h4>
    
    <p>
    <strong>AnyPortrait v1.6.0</strong> has greatly improved the mask function.<br>
    In order to support the added mask function, the clipping shader and alpha mask shader must be changed.<br>
    For the mask function, please refer to <a href="../../en/AdvancedManual/AD_Mask.html">Related Page</a>.<br>
    The <strong>v16 Material Set</strong> provided by default from <strong>AnyPortrait v1.6.0</strong> has changed a lot of clipping-related code compared to the previous version.<br>
    Check out the clipping shader and alpha mask shader code in <strong>v16 Material Set</strong> and use them when writing custom shaders.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"AnyPortrait/Unlit (v16)/AlphaBlend Clipped"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// Basic Clipping Properties</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio</strong></span> (<span class="text-danger">"Mask Ratio"</span>, Range(0, 1)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// 4 Channels for Alpha Masks</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_1</strong></span> (<span class="text-danger">"Mask Ratio Ch1"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_1</strong></span> (<span class="text-danger">"Mask Texture Ch1"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_1</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch1"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_1</strong></span> (<span class="text-danger">"Mask Operation Ch1"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_2</strong></span> (<span class="text-danger">"Mask Ratio Ch2"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_2</strong></span> (<span class="text-danger">"Mask Texture Ch2"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_2</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch2"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_2</strong></span> (<span class="text-danger">"Mask Operation Ch2"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_3</strong></span> (<span class="text-danger">"Mask Ratio Ch3"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_3</strong></span> (<span class="text-danger">"Mask Texture Ch3"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_3</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch3"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_3</strong></span> (<span class="text-danger">"Mask Operation Ch3"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_4</strong></span> (<span class="text-danger">"Mask Ratio Ch4"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_4</strong></span> (<span class="text-danger">"Mask Texture Ch4"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_4</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch4"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_4</strong></span> (<span class="text-danger">"Mask Operation Ch4"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// See-Through Effect </strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughRatio</strong></span> (<span class="text-danger">"See-Through Ratio"</span>, Range(0, 1)) = 0.0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughTex</strong></span> (<span class="text-danger">"See-Through Texture"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughScreenSpaceOffset</strong></span> (<span class="text-danger">"See-Through Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_SeeThroughAlpha</strong></span> (<span class="text-danger">"See-Through Alpha"</span>, Range(0, 1)) = 0.0<br>
    &emsp;&emsp;}<br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags{ <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Screen Position for Clipping Operations</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> screenPos : TEXCOORD1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Basic Clipping Property variables</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Property variables corresponding to the 4 channels for the masks</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_1;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_2;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_3;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_4;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Property variables for see-through effect</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _SeeThroughRatio;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _SeeThroughTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _SeeThroughScreenSpaceOffset;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _SeeThroughAlpha;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask function: Compute Clipping Mask Alpha</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlpha</strong> (<span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask function: Calculate per-channel mask based on operator</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlphaByOp</strong> (<span class="text-primary">float</span> prevMask, <span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio, <span class="text-primary">float</span> op)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> inverseAlpha = 1.0f - alpha;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_And = saturate(prevMask * alpha);//Multiply<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask Function: Compute the UVs of the mask render texture</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> <strong>GetMaskScreenUV</strong> (<span class="text-primary">float2</span> screenUV, <span class="text-primary">float4</span> offset)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> result = screenUV - <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x *= offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y *= offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x += offset.x * offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y += offset.y * offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result += <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return result;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask Function: Calculate See-Through Effect</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half3</span> <strong>GetSeeThroughColor</strong> (<span class="text-primary">half3</span> mainColor, <span class="text-primary">half4</span> seeThroughColor)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> stAlpha = saturate(seeThroughColor.a * _SeeThroughAlpha * _SeeThroughRatio);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return (mainColor * (1.0f - stAlpha)) + (seeThroughColor.rgb * stAlpha);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Calculating Screen Position for Clipping</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.screenPos = ComputeScreenPos(o.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Screen Position for Clipping Mask</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// See-Through Effect</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> seeThroughColor = tex2D(_SeeThroughTex, GetMaskScreenUV(screenUV, _SeeThroughScreenSpaceOffset));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb = GetSeeThroughColor(col.rgb, seeThroughColor);<br>
    <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    #if UNITY_COLORSPACE_GAMMA<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Color calculation (Gamma Space)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    #else<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Color calculation (Linear Space)</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 4.595f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb = pow(col.rgb, 2.2f);<br>
    #endif<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Alpha Mask Calculation Code</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;float maskResult = 1.0f;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 1. Clipping Mask</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 2. 4 Channel Masks</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= maskResult;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;(Shadow Caster Pass is omitted)<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton4" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    The shader above is the basic code of the clipping shader included in <strong>v16 material set</strong>.<br>
    Many mask-related properties have been added compared to before.<br>
    Also, a pass that generates shadows has been added.<br>
    (The explanation of the shadow generation pass is omitted here.)<br>
    </p>
    <br>
    
    <p>
    <strong>1. Properties</strong><br>
    <span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    <span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    <span class="text-danger"><strong>_MaskRatio</strong></span> (<span class="text-danger">"Mask Ratio"</span>, Range(0, 1)) = 0<br>
    <span class="text-danger"><strong>_MaskRatio_1</strong></span> (<span class="text-danger">"Mask Ratio Ch1"</span>, Range(0, 1)) = 0<br>
    <span class="text-danger"><strong>_MaskTex_1</strong></span> (<span class="text-danger">"Mask Texture Ch1"</span>, 2D) = "black" {}<br>
    <span class="text-danger"><strong>_MaskScreenSpaceOffset_1</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch1"</span>, Vector) = (0, 0, 0, 1)<br>
    <span class="text-danger"><strong>_MaskOp_1</strong></span> (<span class="text-danger">"Mask Operation Ch1"</span>, Range(0, 3)) = 0<br>
    : The properties for alpha mask calculation have increased compared to the previous version.<br>
    In addition to the existing <strong>_MaskTex</strong>, <strong>_MaskScreenSpaceOffset</strong>, the <strong>_MaskRatio</strong> property has been added, which determines whether to use the mask for the corresponding channel (clipping and 4 additional channels).<br>
    In addition, the 4 channels have been given additional calculation options, allowing combinations of masks such as AND and OR.<br>
    Please also check the code related to the <strong>_MaskOp_n</strong> property for this.<br>
    </p>
    <br>
    
    <p>
    <span class="text-danger"><strong>_SeeThroughRatio</strong></span> (<span class="text-danger">"See-Through Ratio"</span>, Range(0, 1)) = 0.0<br>
    <span class="text-danger"><strong>_SeeThroughTex</strong></span> (<span class="text-danger">"See-Through Texture"</span>, 2D) = "black" {}<br>
    <span class="text-danger"><strong>_SeeThroughScreenSpaceOffset</strong></span> (<span class="text-danger">"See-Through Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    <span class="text-danger"><strong>_SeeThroughAlpha</strong></span> (<span class="text-danger">"See-Through Alpha"</span>, Range(0, 1)) = 0.0<br>
    : See-Through feature added.<br>
    Similar to alpha mask, but uses both RGBA channels and has the property of overlapping RGB channel values.<br>
    </p>
    <br>
    
    <p>
    <strong>2. Mask calculation functions</strong><br>
    <span class="text-primary">half</span> <strong>GetMaskAlpha</strong> (<span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio)<br>
    : This is a function that calculates the clipping mask.<br>
    It adjusts the degree of Alpha application according to _MaskRatio.<br>
    </p>
    <br>
    
    <p>
    <span class="text-primary">half</span> <strong>GetMaskAlphaByOp</strong> (<span class="text-primary">float</span> prevMask, <span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio, <span class="text-primary">float</span> op)<br>
    : This function calculates the mask for each of the four channels.<br>
    Different formulas are applied depending on the calculation options.<br>
    </p>
    <br>
    
    <p>
    <span class="text-primary">float2</span> <strong>GetMaskScreenUV</strong> (<span class="text-primary">float2</span> screenUV, <span class="text-primary">float4</span> offset)<br>
    : This function performs UV operations to reference masks that utilize Screen Space.<br>
    Since each mask has a separate UV optimization value (MaskScreenSpaceOffset), you must use this function to convert UVs.<br>
    </p>
    <br>
    
    <p>
    <span class="text-primary">half3</span> <strong>GetSeeThroughColor</strong> (<span class="text-primary">half3</span> mainColor, <span class="text-primary">half4</span> seeThroughColor)<br>
    : This is the function that computes the See-Through effect.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"AnyPortrait/Unlit (v16)/AlphaMask"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// Clipping properties according to Mask Chain</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex</strong></span> (<span class="text-danger">"Mask Texture (A)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset</strong></span> (<span class="text-danger">"Mask Screen Space Offset (XY_Scale)"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio</strong></span> (<span class="text-danger">"Mask Ratio"</span>, Range(0, 1)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<strong>// 4 Mask Channels according to Mask Chain</strong><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_1</strong></span> (<span class="text-danger">"Mask Ratio Ch1"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_1</strong></span> (<span class="text-danger">"Mask Texture Ch1"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_1</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch1"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_1</strong></span> (<span class="text-danger">"Mask Operation Ch1"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_2</strong></span> (<span class="text-danger">"Mask Ratio Ch2"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_2</strong></span> (<span class="text-danger">"Mask Texture Ch2"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_2</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch2"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_2</strong></span> (<span class="text-danger">"Mask Operation Ch2"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_3</strong></span> (<span class="text-danger">"Mask Ratio Ch3"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_3</strong></span> (<span class="text-danger">"Mask Texture Ch3"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_3</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch3"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_3</strong></span> (<span class="text-danger">"Mask Operation Ch3"</span>, Range(0, 3)) = 0<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskRatio_4</strong></span> (<span class="text-danger">"Mask Ratio Ch4"</span>, Range(0, 1)) = 0<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskTex_4</strong></span> (<span class="text-danger">"Mask Texture Ch4"</span>, 2D) = "black" {}<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskScreenSpaceOffset_4</strong></span> (<span class="text-danger">"Mask Screen Space Offset Ch4"</span>, Vector) = (0, 0, 0, 1)<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>_MaskOp_4</strong></span> (<span class="text-danger">"Mask Operation Ch4"</span>, Range(0, 3)) = 0<br>
    &emsp;&emsp;}<br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType"="Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;Cull Off<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Screen Position for Clipping Operations</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> screenPos : TEXCOORD1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Basic Clipping Property variables</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 4 Mask Channel Property variables</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_1;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_1;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_2;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_2;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_3;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_3;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskRatio_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MaskTex_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MaskScreenSpaceOffset_4;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> _MaskOp_4;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask Function: Compute Clipping Mask Alpha</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlpha</strong> (<span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask Function: Calculate per-channel mask based on operator</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> <strong>GetMaskAlphaByOp</strong> (<span class="text-primary">float</span> prevMask, <span class="text-primary">float</span> alpha, <span class="text-primary">float</span> ratio, <span class="text-primary">float</span> op)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> inverseAlpha = 1.0f - alpha;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_And = saturate(prevMask * alpha);//Multiply<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask Function: Compute the UVs of the mask render texture</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> <strong>GetMaskScreenUV</strong> (<span class="text-primary">float2</span> screenUV, <span class="text-primary">float4</span> offset)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> result = screenUV - <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x *= offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y *= offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.x += offset.x * offset.z;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result.y += offset.y * offset.w;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result += <span class="text-primary">float2</span>(0.5f, 0.5f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return result;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Calculating Screen Position for Clipping</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.screenPos = ComputeScreenPos(o.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb = fixed3(1.0f, 1.0f, 1.0f);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a = saturate(col.a * _Color.a);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// Mask operations for Mask Chains</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskResult = 1.0f;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 1. Clipping Mask</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half</span> maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>// 2. 4 Channel Masks</strong><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float</span> maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;maskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= maskResult;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton5" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    The shader above is the basic code of the alpha mask shader of <strong>v16 Material Set</strong>.<br>
    Previously, it simply performed the role of calculating only the alpha channel on white, but mask-related code was added in AnyPortrait v1.6.0.<br>
    This is to support the <strong>Mask Chain</strong> function. (<a href="../../en/AdvancedManual/AD_MaskChain.html">Related Page</a>)<br>
    The clipping-related code is the same as the clipping shader, and the See-Through effect that is not related to the alpha channel is excluded from this shader.<br>
    </p>
    <br>
    
    <br>
    <br>
    <!-- 3. 서브 타이틀 -->
    <h3>Using Keywords in Shaders</h3>
    <br>
    
    <p>
    You can use keywords to compile a single shader code into multiple versions.<br>
    You can use keywords in shaders using the features added in AnyPortrait v1.5.1.<br>
    You can see related information about keywords in the following official Unity documentation.<br>
    - <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/SL-MultipleProgramVariants.html" target="_sub">Unity Manual</a><br>
    </p>
    <br>
    
    <p>
    Here's an example shader where color operations change based on the keyword "<strong>SPECIAL_COLOR</strong>".<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    Shader <span class="text-danger">"Shader Example/Gamma Space - Normal - AlphaBlend (Keyword)"</span><br>
    {<br>
    &emsp;&emsp;Properties<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;_Color (<span class="text-danger">"2X Color (RGBA Mul)"</span>, Color) = (0.5, 0.5, 0.5, 1.0)<br>
    &emsp;&emsp;&emsp;&emsp;_MainTex (<span class="text-danger">"Main Texture (RGBA)"</span>, 2D) = "white" {}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;SubShader<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;Tags { <span class="text-danger">"RenderType" = "Transparent" "Queue" = "Transparent" "PreviewType" = "Plane"</span> }<br>
    &emsp;&emsp;&emsp;&emsp;Blend SrcAlpha OneMinusSrcAlpha<br>
    &emsp;&emsp;&emsp;&emsp;LOD 200<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;Pass<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ZWrite Off<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;CGPROGRAM<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma vertex vert<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#pragma fragment frag<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>#pragma multi_compile __ SPECIAL_COLOR</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#include "UnityCG.cginc"<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> appdata<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : POSITION;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">struct</span> v2f<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float2</span> uv : TEXCOORD0;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> vertex : SV_POSITION;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;};<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">sampler2D</span> _MainTex;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">float4</span> _MainTex_ST;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">half4</span> _Color;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> vert (<span class="text-primary">appdata</span> v)<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">v2f</span> o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.vertex = UnityObjectToClipPos(v.vertex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o.uv = TRANSFORM_TEX(v.uv, _MainTex);<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> frag (<span class="text-primary">v2f</span> i) : SV_Target<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-primary">fixed4</span> col = tex2D(_MainTex, i.uv);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.rgb *= _Color.rgb * 2.0f;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;col.a *= _Color.a;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>#ifdef SPECIAL_COLOR</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>col.rgb *= fixed3(0.0f, 1.0f, 0.0f);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>#endif</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return col;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ENDCG<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    <button id="scriptcopybutton6" class="btn btn-info float-right">Copy to Clipboard</button>
    <br><br>
    
    </div>
    <br>
    
    <p>
    <strong>1. Declaring keywords</strong><br>
    <span class="text-danger"><strong>#pragma multi_compile __ SPECIAL_COLOR</strong></span><br>
    : Declare keywords using the <strong>#pragma multi_compile</strong> syntax.<br>
    In this example, a new keyword called "<strong>SPECIAL_COLOR</strong>" is declared.<br>
    You can use keywords in Unity using the "<strong>multi_compile</strong>" and "<strong>shader_feature</strong>" directives that generate shader variants, or the "<strong>dynamic_branch</strong>" directive that generates dynamic branches.<br>
    However, since AnyPortrait generates materials dynamically, you cannot use "<strong>shader_feature</strong>" that compiles shader variants based on assets.<br>
    </p>
    <br>
    
    <p>
    <strong>2. Writing code branches</strong><br>
    <span class="text-danger"><strong>#ifdef SPECIAL_COLOR</strong></span><br>
    <span class="text-danger"><strong>col.rgb *= fixed3(0.0f, 1.0f, 0.0f);</strong></span><br>
    <span class="text-danger"><strong>#endif</strong></span><br>
    : Write to behave differently depending on the keyword.<br>
    If you use "<strong>multi_compile</strong>", use the "#ifdef, #else, #elif, #endif" directives, and if you use "<strong>dynamic_branch</strong>", use the "if ( )" statement.<br>
    In this example, if the "<strong>SPECIAL_COLOR</strong>" keyword is enabled, only the color of the green channel is rendered.<br>
    </p>
    <br>
    
    <p>
    To use keywords, you need to set them in <strong>Material Library</strong>.<br>
    For more information, please refer to the <a href="../../en/AdvancedManual/AD_MaterialLibrary.html">Related page</a>.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_2055.jpg"/>
    <br>
    
    <p>
    <strong>(1)</strong> Open the Material Library.<br>
    <strong>(2)</strong> Add a property option named "<strong>SPECIAL_COLOR</strong>", set it to "<strong>Keyword</strong>" type, and set it to "<strong>Enable</strong>".<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_2056.jpg"/>
    <br>
    
    <p>
    If you bake and run it, you can see that the rendering result changes depending on whether the keyword is activated or not, as shown above.<br>
    </p>
    <br>
    
    <!-- 5. 바닥 네비바 -->
    <br>
    <br>
    <br>
    <br>
    <nav class="navbar fixed-bottom navbar-light bg-light">
        <a class="btn btn-light" role="button" href="../../en/Script/SC_Physics.html">< Physic Effect</a>
        <a class="btn btn-light" role="button" href="../../en/Script/SC_Timeline.html">Timeline ></a>
    </nav>
    
    <!-- 페이지 내용 끝! -->

    
    <!-- 종료 -->
    </div>

    <!-- 부트스트랩 -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script type="text/javascript" src="../../js/bootstrap.js"></script>
    <!--------------->

    <!-- 클립보드 스크립트 -->
    <script>
    document.getElementById("scriptcopybutton0").addEventListener("click", function() {
    const textToCopy = "Shader \"Sample Shader/Gamma Space - Normal - AlphaBlend\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\t}\n\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tTags { \"LightMode\" = \"ForwardBase\" }\n\t\t\tZWrite Off\n\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\t\t\t\t\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\n\t\tPass\n\t\t{\n\t\t\tTags { \"LightMode\" = \"ShadowCaster\" }\n\t\t\tZWrite On\n\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t#pragma multi_compile_shadowcaster\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{ \n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tV2F_SHADOW_CASTER;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\tv2f vert(appdata_base v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\tTRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n\t\t\t\to.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfloat4 frag(v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\tif(col.a < 0.05f)\n\t\t\t\t{\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\tSHADOW_CASTER_FRAGMENT(i)\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton1").addEventListener("click", function() {
    const textToCopy = "\t\t\t...\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 4.595f;\n\t\t\t\tcol.rgb = pow(col.rgb, 2.2f);\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\t...\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton2").addEventListener("click", function() {
    const textToCopy = "\t...\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\n\t\t// --- Select and write according to the blending type ---\n\t\tBlend One One // Additive\n\t\tBlend OneMinusDstColor One // Soft Additive\n\t\tBlend DstColor SrcColor // Multiplicative\n\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\t// --- Delete Pass Tags ---\n\t\t\t// Tags { \"LightMode\" = \"ForwardBase\" }\n\t\t\tZWrite Off\n\n\t\t\tCGPROGRAM\n\t\t\t...\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t// --- Additive 또는 Soft Additive ---\n\t\t\t\tcol.rgb *= col.a;\n\t\t\t\tcol.a = 1.0f;\n\t\t\t\t// ---------------------------------\n\n\t\t\t\t// --- Multiplicative ---\n\t\t\t\tcol.rgb = col.rgb * (col.a) + float4(0.5f, 0.5f, 0.5f, 1.0f) * (1.0f - col.a);\n\t\t\t\tcol.a = 1.0f;\n\t\t\t\t// ----------------------\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t\t// Delete Shadow Generation Pass\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton3").addEventListener("click", function() {
    const textToCopy = "Shader \"Sample Shader/Gamma Space - Clipped - AlphaBlend\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\n\t\t// --- Clipping properties ---\n\t\t_MaskTex (\"Mask Texture (A)\", 2D) = \"white\" {}\n\t\t_MaskScreenSpaceOffset (\"Mask Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t}\n\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tZWrite Off\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\n\t\t\t\t// --- Screen Position for Clipping Operations ---\n\t\t\t\tfloat4 screenPos : TEXCOORD1;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\t// --- Property variables for Clipping ---\n\t\t\tsampler2D _MaskTex;\n\t\t\tfloat4 _MaskScreenSpaceOffset;\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\n\t\t\t\t// --- Calculating Screen Position for Clipping ---\n\t\t\t\to.screenPos = ComputeScreenPos(o.vertex);\n\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t// --- Set Alpha channel by Clipping mask ---\n\t\t\t\tfloat2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);\n\t\t\t\tscreenUV -= float2(0.5f, 0.5f);\n\t\t\t\tscreenUV.x *= _MaskScreenSpaceOffset.z;\n\t\t\t\tscreenUV.y *= _MaskScreenSpaceOffset.w;\n\t\t\t\tscreenUV.x += _MaskScreenSpaceOffset.x * _MaskScreenSpaceOffset.z;\n\t\t\t\tscreenUV.y += _MaskScreenSpaceOffset.y * _MaskScreenSpaceOffset.w;\n\t\t\t\tscreenUV += float2(0.5f, 0.5f);\n\t\t\t\tcol.a *= tex2D(_MaskTex, screenUV).r;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton4").addEventListener("click", function() {
    const textToCopy = "Shader \"AnyPortrait/Unlit (v16)/AlphaBlend Clipped\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\n\t\t// Basic Clipping Properties\n\t\t_MaskTex (\"Mask Texture (A)\", 2D) = \"white\" {}\n\t\t_MaskScreenSpaceOffset (\"Mask Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t\t_MaskRatio (\"Mask Ratio\", Range(0, 1)) = 0\n\n\t\t// 4 Channels for Alpha Masks\n\t\t_MaskRatio_1 (\"Mask Ratio Ch1\", Range(0, 1)) = 0\n\t\t_MaskTex_1 (\"Mask Texture Ch1\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_1 (\"Mask Screen Space Offset Ch1\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_1 (\"Mask Operation Ch1\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_2 (\"Mask Ratio Ch2\", Range(0, 1)) = 0\n\t\t_MaskTex_2 (\"Mask Texture Ch2\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_2 (\"Mask Screen Space Offset Ch2\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_2 (\"Mask Operation Ch2\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_3 (\"Mask Ratio Ch3\", Range(0, 1)) = 0\n\t\t_MaskTex_3 (\"Mask Texture Ch3\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_3 (\"Mask Screen Space Offset Ch3\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_3 (\"Mask Operation Ch3\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_4 (\"Mask Ratio Ch4\", Range(0, 1)) = 0\n\t\t_MaskTex_4 (\"Mask Texture Ch4\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_4 (\"Mask Screen Space Offset Ch4\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_4 (\"Mask Operation Ch4\", Range(0, 3)) = 0\n\n\t\t// See-Through Effect \n\t\t_SeeThroughRatio (\"See-Through Ratio\", Range(0, 1)) = 0.0\n\t\t_SeeThroughTex (\"See-Through Texture\", 2D) = \"black\" {}\n\t\t_SeeThroughScreenSpaceOffset (\"See-Through Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t\t_SeeThroughAlpha (\"See-Through Alpha\", Range(0, 1)) = 0.0\n\t}\n\tSubShader\n\t{\n\t\tTags{ \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tZWrite Off\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\n\t\t\t\t// Screen Position for Clipping Operations\n\t\t\t\tfloat4 screenPos : TEXCOORD1;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\t// Basic Clipping Property variables\n\t\t\tsampler2D _MaskTex;\n\t\t\tfloat4 _MaskScreenSpaceOffset;\n\t\t\tfloat _MaskRatio;\n\n\t\t\t// Property variables corresponding to the 4 channels for the masks\n\t\t\tfloat _MaskRatio_1;\n\t\t\tsampler2D _MaskTex_1;\n\t\t\tfloat4 _MaskScreenSpaceOffset_1;\n\t\t\tfloat _MaskOp_1;\n\n\t\t\tfloat _MaskRatio_2;\n\t\t\tsampler2D _MaskTex_2;\n\t\t\tfloat4 _MaskScreenSpaceOffset_2;\n\t\t\tfloat _MaskOp_2;\n\n\t\t\tfloat _MaskRatio_3;\n\t\t\tsampler2D _MaskTex_3;\n\t\t\tfloat4 _MaskScreenSpaceOffset_3;\n\t\t\tfloat _MaskOp_3;\n\n\t\t\tfloat _MaskRatio_4;\n\t\t\tsampler2D _MaskTex_4;\n\t\t\tfloat4 _MaskScreenSpaceOffset_4;\n\t\t\tfloat _MaskOp_4;\n\n\t\t\t// Property variables for see-through effect\n\t\t\tfloat _SeeThroughRatio;\n\t\t\tsampler2D _SeeThroughTex;\n\t\t\tfloat4 _SeeThroughScreenSpaceOffset;\n\t\t\tfloat _SeeThroughAlpha;\n\n\t\t\t// Mask function: Compute Clipping Mask Alpha\n\t\t\thalf GetMaskAlpha (float alpha, float ratio)\n\t\t\t{\n\t\t\t\treturn saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// Mask function: Calculate per-channel mask based on operator\n\t\t\thalf GetMaskAlphaByOp (float prevMask, float alpha, float ratio, float op)\n\t\t\t{\n\t\t\t\tfloat opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND\n\t\t\t\tfloat opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR\n\t\t\t\tfloat opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND\n\t\t\t\tfloat opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR\n\n\t\t\t\tfloat inverseAlpha = 1.0f - alpha;\n\n\t\t\t\tfloat nextAlpha_And = saturate(prevMask * alpha);//Multiply\n\t\t\t\tfloat nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended\n\t\t\t\tfloat nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)\n\t\t\t\tfloat nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)\n\n\t\t\t\tfloat resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);\n\n\t\t\t\treturn saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// Mask Function: Compute the UVs of the mask render texture\n\t\t\tfloat2 GetMaskScreenUV (float2 screenUV, float4 offset)\n\t\t\t{\n\t\t\t\tfloat2 result = screenUV - float2(0.5f, 0.5f);\n\t\t\t\tresult.x *= offset.z;\n\t\t\t\tresult.y *= offset.w;\n\t\t\t\tresult.x += offset.x * offset.z;\n\t\t\t\tresult.y += offset.y * offset.w;\n\t\t\t\tresult += float2(0.5f, 0.5f);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Mask Function: Calculate See-Through Effect\n\t\t\thalf3 GetSeeThroughColor (half3 mainColor, half4 seeThroughColor)\n\t\t\t{\n\t\t\t\tfloat stAlpha = saturate(seeThroughColor.a * _SeeThroughAlpha * _SeeThroughRatio);\n\t\t\t\treturn (mainColor * (1.0f - stAlpha)) + (seeThroughColor.rgb * stAlpha);\n\t\t\t}\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\n\t\t\t\t// Calculating Screen Position for Clipping\n\t\t\t\to.screenPos = ComputeScreenPos(o.vertex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\t// Screen Position for Clipping Mask\n\t\t\t\tfloat2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);\n\n\t\t\t\t// See-Through Effect\n\t\t\t\thalf4 seeThroughColor = tex2D(_SeeThroughTex, GetMaskScreenUV(screenUV, _SeeThroughScreenSpaceOffset));\n\t\t\t\tcol.rgb = GetSeeThroughColor(col.rgb, seeThroughColor);\n\n\t\t\t\t\n#if UNITY_COLORSPACE_GAMMA\n\t\t\t\t// Color calculation (Gamma Space)\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n#else\n\t\t\t\t// Color calculation (Linear Space)\n\t\t\t\tcol.rgb *= _Color.rgb * 4.595f;\n\t\t\t\tcol.rgb = pow(col.rgb, 2.2f);\n#endif\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t// Alpha Mask Calculation Code\n\t\t\t\tfloat maskResult = 1.0f;\n\n\t\t\t\t// 1. Clipping Mask\n\t\t\t\thalf maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;\n\t\t\t\tmaskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));\n\n\t\t\t\t// 2. 4 Channel Masks\n\t\t\t\tfloat maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;\n\t\t\t\tfloat maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;\n\t\t\t\tfloat maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;\n\t\t\t\tfloat maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;\n\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);\n\n\t\t\t\tcol.a *= maskResult;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t(Shadow Caster Pass is omitted)\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton5").addEventListener("click", function() {
    const textToCopy = "Shader \"AnyPortrait/Unlit (v16)/AlphaMask\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\n\t\t// Clipping properties according to Mask Chain\n\t\t_MaskTex (\"Mask Texture (A)\", 2D) = \"white\" {}\n\t\t_MaskScreenSpaceOffset (\"Mask Screen Space Offset (XY_Scale)\", Vector) = (0, 0, 0, 1)\n\t\t_MaskRatio (\"Mask Ratio\", Range(0, 1)) = 0\n\n\t\t// 4 Mask Channels according to Mask Chain\n\t\t_MaskRatio_1 (\"Mask Ratio Ch1\", Range(0, 1)) = 0\n\t\t_MaskTex_1 (\"Mask Texture Ch1\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_1 (\"Mask Screen Space Offset Ch1\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_1 (\"Mask Operation Ch1\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_2 (\"Mask Ratio Ch2\", Range(0, 1)) = 0\n\t\t_MaskTex_2 (\"Mask Texture Ch2\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_2 (\"Mask Screen Space Offset Ch2\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_2 (\"Mask Operation Ch2\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_3 (\"Mask Ratio Ch3\", Range(0, 1)) = 0\n\t\t_MaskTex_3 (\"Mask Texture Ch3\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_3 (\"Mask Screen Space Offset Ch3\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_3 (\"Mask Operation Ch3\", Range(0, 3)) = 0\n\n\t\t_MaskRatio_4 (\"Mask Ratio Ch4\", Range(0, 1)) = 0\n\t\t_MaskTex_4 (\"Mask Texture Ch4\", 2D) = \"black\" {}\n\t\t_MaskScreenSpaceOffset_4 (\"Mask Screen Space Offset Ch4\", Vector) = (0, 0, 0, 1)\n\t\t_MaskOp_4 (\"Mask Operation Ch4\", Range(0, 3)) = 0\n\t}\n\tSubShader\n\t{\n\t\tTags { \"RenderType\"=\"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tZWrite Off\n\t\tCull Off\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\n\t\t\t\t// Screen Position for Clipping Operations\n\t\t\t\tfloat4 screenPos : TEXCOORD1;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\t// Basic Clipping Property variables\n\t\t\tsampler2D _MaskTex;\n\t\t\tfloat4 _MaskScreenSpaceOffset;\n\t\t\tfloat _MaskRatio;\n\n\t\t\t// 4 Mask Channel Property variables\n\t\t\tfloat _MaskRatio_1;\n\t\t\tsampler2D _MaskTex_1;\n\t\t\tfloat4 _MaskScreenSpaceOffset_1;\n\t\t\tfloat _MaskOp_1;\n\n\t\t\tfloat _MaskRatio_2;\n\t\t\tsampler2D _MaskTex_2;\n\t\t\tfloat4 _MaskScreenSpaceOffset_2;\n\t\t\tfloat _MaskOp_2;\n\n\t\t\tfloat _MaskRatio_3;\n\t\t\tsampler2D _MaskTex_3;\n\t\t\tfloat4 _MaskScreenSpaceOffset_3;\n\t\t\tfloat _MaskOp_3;\n\n\t\t\tfloat _MaskRatio_4;\n\t\t\tsampler2D _MaskTex_4;\n\t\t\tfloat4 _MaskScreenSpaceOffset_4;\n\t\t\tfloat _MaskOp_4;\n\n\t\t\t// Mask Function: Compute Clipping Mask Alpha\n\t\t\thalf GetMaskAlpha (float alpha, float ratio)\n\t\t\t{\n\t\t\t\treturn saturate((alpha * ratio) + (1.0f * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// Mask Function: Calculate per-channel mask based on operator\n\t\t\thalf GetMaskAlphaByOp (float prevMask, float alpha, float ratio, float op)\n\t\t\t{\n\t\t\t\tfloat opWeight_And = saturate(1.0f - abs(op - 0.0f));//AND\n\t\t\t\tfloat opWeight_Or = saturate(1.0f - abs(op - 1.0f));//OR\n\t\t\t\tfloat opWeight_InvAnd = saturate(1.0f - abs(op - 2.0f));//Inverse AND\n\t\t\t\tfloat opWeight_InvOr = saturate(1.0f - abs(op - 3.0f));//Inverse OR\n\n\t\t\t\tfloat inverseAlpha = 1.0f - alpha;\n\n\t\t\t\tfloat nextAlpha_And = saturate(prevMask * alpha);//Multiply\n\t\t\t\tfloat nextAlpha_Or = saturate(prevMask + (alpha * (1.0f - prevMask)));//Add Blended\n\t\t\t\tfloat nextAlpha_InvAnd = saturate(prevMask * inverseAlpha);//Multiply (Inverse)\n\t\t\t\tfloat nextAlpha_InvAOr = saturate(prevMask + (inverseAlpha * (1.0f - prevMask)));//Add Blended (Inverse)\n\n\t\t\t\tfloat resultMask = (nextAlpha_And * opWeight_And) + (nextAlpha_Or * opWeight_Or) + (nextAlpha_InvAnd * opWeight_InvAnd) + (nextAlpha_InvAOr * opWeight_InvOr);\n\n\t\t\t\treturn saturate((resultMask * ratio) + (prevMask * (1.0f - ratio)));\n\t\t\t}\n\n\t\t\t// Mask Function: Compute the UVs of the mask render texture\n\t\t\tfloat2 GetMaskScreenUV (float2 screenUV, float4 offset)\n\t\t\t{\n\t\t\t\tfloat2 result = screenUV - float2(0.5f, 0.5f);\n\t\t\t\tresult.x *= offset.z;\n\t\t\t\tresult.y *= offset.w;\n\t\t\t\tresult.x += offset.x * offset.z;\n\t\t\t\tresult.y += offset.y * offset.w;\n\t\t\t\tresult += float2(0.5f, 0.5f);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\n\t\t\t\t// Calculating Screen Position for Clipping\n\t\t\t\to.screenPos = ComputeScreenPos(o.vertex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb = fixed3(1.0f, 1.0f, 1.0f);\n\t\t\t\tcol.a = saturate(col.a * _Color.a);\n\n\t\t\t\t// Mask operations for Mask Chains\n\t\t\t\tfloat2 screenUV = i.screenPos.xy / max(i.screenPos.w, 0.0001f);\n\n\t\t\t\tfloat maskResult = 1.0f;\n\n\t\t\t\t// 1. Clipping Mask\n\t\t\t\thalf maskClipped = tex2D(_MaskTex, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset)).r;\n\t\t\t\tmaskResult *= GetMaskAlpha(saturate(maskClipped), saturate(_MaskRatio));\n\n\t\t\t\t// 2. 4 Channel Masks\n\t\t\t\tfloat maskCh1 = tex2D(_MaskTex_1, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_1)).r;\n\t\t\t\tfloat maskCh2 = tex2D(_MaskTex_2, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_2)).r;\n\t\t\t\tfloat maskCh3 = tex2D(_MaskTex_3, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_3)).r;\n\t\t\t\tfloat maskCh4 = tex2D(_MaskTex_4, GetMaskScreenUV(screenUV, _MaskScreenSpaceOffset_4)).r;\n\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh1), saturate(_MaskRatio_1), _MaskOp_1);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh2), saturate(_MaskRatio_2), _MaskOp_2);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh3), saturate(_MaskRatio_3), _MaskOp_3);\n\t\t\t\tmaskResult = GetMaskAlphaByOp(maskResult, saturate(maskCh4), saturate(_MaskRatio_4), _MaskOp_4);\n\n\t\t\t\tcol.a *= maskResult;\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    
    <script>
    document.getElementById("scriptcopybutton6").addEventListener("click", function() {
    const textToCopy = "Shader \"Shader Example/Gamma Space - Normal - AlphaBlend (Keyword)\"\n{\n\tProperties\n\t{\n\t\t_Color (\"2X Color (RGBA Mul)\", Color) = (0.5, 0.5, 0.5, 1.0)\n\t\t_MainTex (\"Main Texture (RGBA)\", 2D) = \"white\" {}\n\t}\n\n\tSubShader\n\t{\n\t\tTags { \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\" \"PreviewType\" = \"Plane\" }\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\t\tLOD 200\n\n\t\tPass\n\t\t{\n\t\t\tZWrite Off\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\t#pragma multi_compile __ SPECIAL_COLOR\n\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\t\t\t\t\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat4 _MainTex_ST;\n\t\t\thalf4 _Color;\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\n\t\t\t\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t\t\t\tcol.rgb *= _Color.rgb * 2.0f;\n\t\t\t\tcol.a *= _Color.a;\n\n\t\t\t\t#ifdef SPECIAL_COLOR\n\t\t\t\tcol.rgb *= fixed3(0.0f, 1.0f, 0.0f);\n\t\t\t\t#endif\n\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n";
    navigator.clipboard.writeText(textToCopy).then(() => {
        alert("The script has been copied to the clipboard.");
    }).catch(err => {
        console.error("Clipboard copy failed:", err);
    });
    });
    </script>
    

    <!--------------->

    </body>
</html>
