<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <!-- 제목 -->
        <title>메시 부착시의 Sorting Order 설정</title>
        <!-- 파비콘 -->
        <link rel="shortcut icon" href="../../Images/favicon.ico"/>
        <!-- 부트스트랩 -->
        <link rel="stylesheet" href="../../css/bootstrap.css">
        <!--------------->

    </head>

    <body>
        <p>
            <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
            <!--로고 : AnyPortrait 홈페이지로 가야한다. (언어별)-->
            <a class="navbar-brand" href="https://www.rainyrizzle.com/anyportrait-kor">
                <img src="../../Images/AP_Logo.png" width="150" height="30" class="d-inline-block align-top" alt="">
            </a>

            <!--메뉴들 : 현재 페이지의 카테고리에 active 붙인다. (언어별 링크) -->
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarText">
                <ul class="navbar-nav mr-auto">
                <li class="nav-item">
                    <a class="nav-link" href="../../kr/GettingStarted.html">시작하기</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../kr/AdManual.html">메뉴얼</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="../../kr/Script.html">스크립트</a>
                </li>

                </ul>

                <!-- 언어 변경. 현재 페이지의 주소에서 언어 주소만 변경한다. (해당 언어에 active) -->
                <div class="btn-group mr-2" role="group" aria-label="Basic example">
                    <a role="button" class="btn btn-secondary" href="../../en/AdvancedManual/AD_SortingOrderInAttachMesh.html">EN</a>
                    <a role="button" class="btn btn-secondary active" href="../../kr/AdvancedManual/AD_SortingOrderInAttachMesh.html">KR</a>
                    <a role="button" class="btn btn-secondary" href="../../jp/AdvancedManual/AD_SortingOrderInAttachMesh.html">JP</a>
                </div>

                <!-- 여백 -->
                <p></p>

                <!-- 검색버튼 -->
                <form class="form-inline">
                    <a class="btn btn-light" role="button" href="../../kr/Search.html">검색</a>
                </form>
            </div>
        </nav>
    </p>

    <!-- 실제 바디 부분 -->
    <div class="container">
    <br>
    <br>
    <!-- 여기에 내용을 적어주세요 -->

    <!-- 여기서부터 페이지 내용이 작성됩니다. -->
    <!-- 1. 페이지 진입 경로 -->
    <p><a href="https://www.rainyrizzle.com/anyportrait-kor"><span class="text-dark">AnyPortrait</span></a> > <a href="../../kr/AdManual.html"><span class="text-dark">메뉴얼</span></a> > 메시 부착시의 Sorting Order 설정</p>
    
    <!-- 2. 페이지 메인 타이틀 -->
    <h1 class="display-5">메시 부착시의 Sorting Order 설정</h1>
    <br>
    
    <!-- 4. 버전 설명 -->
    <h4><span class="badge badge-secondary">1.3.4</span></h4>
    
    <p>
    게임을 만들다보면 서로 다른 캐릭터를 합쳐서 렌더링하거나, 외부의 메시를 의상이나 무기처럼 장착하는 것을 만들곤 합니다.<br>
    이때, 부착된 메시들의 렌더링 순서를 적절하게 수정하는 것은 매우 중요합니다.<br>
    다른 메뉴얼에서 <strong>Sorting Order</strong>를 이용하여 렌더링 순서를 정하는 방법에 대해서 소개한 적이 있습니다.<br>
    여기에 더해서, 이 페이지는 "<strong>Extra 설정</strong>"에 의해 실시간으로 메시의 렌더링 순서가 바뀌는 경우에 대해서도 다룹니다.<br>
    이 페이지와 관련된 아래의 메뉴얼들을 함께 보시면 도움이 될 것입니다.<br>
    - <a href="../../kr/Script/SC_Init.html">스크립트 : 초기화, 기본 설정</a><br>
    - <a href="../../kr/Script/SC_Mesh.html">스크립트 : 메시, 메시 그룹 트랜스폼</a><br>
    - <a href="../../kr/AdvancedManual/AD_SortingLayer.html">Sorting Layer/Order 설정</a><br>
    - <a href="../../kr/AdvancedManual/AD_ExtraOption.html">렌더링 순서와 이미지 전환하기</a><br>
    - <a href="../../kr/AdvancedManual/AD_AttachEquipments.html">캐릭터에 아이템 장착하기</a><br>
    - <a href="../../kr/AdvancedManual/AD_SynchronizeWithOthers.html">다른 캐릭터와 동기화된 재생</a><br>
    - <a href="../../kr/AdvancedManual/AD_SyncBonesToChangeCostumes.html">본을 동기화하여 의상 교체하기</a><br>
    </p>
    <br>
    
    <p>
    특히 이 예제에서는 "<strong>본 동기화</strong>" 기능을 이용합니다.<br>
    본 동기화에 대한 자세한 설명은 <a href="../../kr/AdvancedManual/AD_SyncBonesToChangeCostumes.html">관련 페이지</a>에서 확인해주세요.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1389.jpg"/>
    <br>
    
    <p>
    설명을 위해 만들어진 로봇 캐릭터입니다.<br>
    이 로봇이 가진 한개의 팔이 몸 주위를 돌면서 움직이도록 만들 것입니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1390.jpg"/>
    <br>
    
    <p>
    팔이 몸의 앞, 뒤로 움직이도록 만들기 위해서는 "<strong>Extra 설정</strong>" (<a href="../../kr/AdvancedManual/AD_ExtraOption.html">관련 페이지</a>)을 이용해야합니다.<br>
    <strong>(1)</strong> "<strong>Color Only (Controller)</strong>" 모디파이어를 추가합니다.<br>
    <strong>(2)</strong> "<strong>Extra Option</strong>"을 활성화합니다.<br>
    <strong>(3)</strong> 팔의 렌더링 위치를 제어할 컨트롤 파라미터를 생성한 상태에서 키들을 추가합니다.<br>
    <strong>(4)</strong> 팔 메시들을 선택합니다.<br>
    <strong>(5)</strong> "<strong>Set</strong>" 버튼을 눌러서 "<strong>Extra 설정</strong>" 다이얼로그를 엽니다.<br>
    <strong>(6)</strong> 메시들의 <strong>Detph</strong>가 몸의 앞, 뒤로 이동하도록 만듭니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1391.jpg"/>
    <br>
    
    <p>
    팔이 컨트롤 파라미터에 따라서 몸의 앞 또는 뒤에서 렌더링되도록 만들었습니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1392.jpg"/>
    <br>
    
    <p>
    본 애니메이션까지 적용하여 완성된 애니메이션 입니다.<br>
    팔이 몸 주위를 빙글빙글 돌면서 움직이는 것을 볼 수 있습니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1393.jpg"/>
    <br>
    
    <p>
    새로운 캐릭터를 만듭니다.<br>
    이 캐릭터는 "로봇 팔에 장착되는 장비"입니다.<br>
    "Equip1 ~ 4"라는 4개의 메시들을 가지고 있습니다.<br>
    이 캐릭터는 "본 동기화"를 이용하기 위해 제작되었습니다.<br>
    제작 방법 및 아래의 스크립트에 대한 설명은 <a href="../../kr/AdvancedManual/AD_SyncBonesToChangeCostumes.html">관련 페이지</a>에서 자세히 알아볼 수 있습니다.<br>
    </p>
    <br>
    
    <p>
    이제 스크립트를 작성하여 장비가 로봇 팔에 부착되도록 만들어 봅시다.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    using UnityEngine;<br>
    using AnyPortrait;<br>
    <br>
    public class RobotDepthSyncScript : MonoBehaviour<br>
    {&emsp;&emsp;<br>
    &emsp;&emsp;public Transform robotGroup; // 로봇의 부모 GameObject입니다.<br>
    &emsp;&emsp;public apPortrait mainCharacter; // 로봇 캐릭터입니다.<br>
    &emsp;&emsp;public apPortrait equipment; // 로봇에 부착될 장비 캐릭터입니다.<br>
    <br>
    &emsp;&emsp;void Start()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;void Update()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// A키를 누르면 장비가 부착됩니다.<br>
    &emsp;&emsp;&emsp;&emsp;if(Input.GetKeyDown(KeyCode.A))<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Attach();<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// S키를 누르면 부착이 해제됩니다.<br>
    &emsp;&emsp;&emsp;&emsp;if(Input.GetKeyDown(KeyCode.S))<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Detach();<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;private void Attach()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비를 로봇의 부모 게임 오브젝트의 자식으로 등록합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.parent = robotGroup;<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.localPosition = Vector3.zero;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 본을 동기화합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.<strong>Synchronize</strong>(mainCharacter, false, false, false, true, SYNC_BONE_OPTION.MatchFromRoot);<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;private void Detach()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비를 로봇의 부모 게임 오브젝트로부터 분리합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.parent = null;<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.position = new Vector3(-5, 0, 0);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 동기화를 해제합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.<strong>Unsynchronize()</strong>;<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    </div>
    <br>
    
    <p>
    위와 같은 간단한 스크립트를 통해서 같은 본을 가진 두개의 캐릭터가 동기화되도록 만들 수 있습니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1394.jpg"/>
    <br>
    
    <p>
    작성한 스크립트를 유니티에서 적용해봅시다.<br>
    <strong>(1)</strong> "RobotGroup"이라는 새로운 GameObject를 생성하고, 로봇 캐릭터를 자식으로서 등록시킵니다. 스크립트를 추가할 GameObject도 생성합니다.<br>
    <strong>(2)</strong> 스크립트의 멤버들까지 할당하여 구성된 유니티 씬입니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1395.jpg"/>
    <br>
    
    <p>
    게임을 실행시켜서 A키를 누르면 장비가 로봇에 달라붙어서 움직이는 것을 볼 수 있습니다.<br>
    하지만 장비의 메시들이 렌더링되는 순서가 매우 이상해 보입니다.<br>
    </p>
    <br>
    
    <p>
    스크립트를 수정해서 렌더링 순서를 지정해봅시다.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    using UnityEngine;<br>
    using AnyPortrait;<br>
    <br>
    public class RobotDepthSyncScript : MonoBehaviour<br>
    {&emsp;&emsp;<br>
    &emsp;&emsp;public Transform robotGroup; // 로봇의 부모 GameObject입니다.<br>
    &emsp;&emsp;public apPortrait mainCharacter; // 로봇 캐릭터입니다.<br>
    &emsp;&emsp;public apPortrait equipment; // 로봇에 부착될 장비 캐릭터입니다.<br>
    <br>
    &emsp;&emsp;// Sorting Order값을 참조할 로봇 팔의 메시 중 하나를 변수로 저장합니다.<br>
    &emsp;&emsp;<span class="text-danger"><strong>private apOptTransform targetMesh;</strong></span><br>
    <br>
    &emsp;&emsp;void Start()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비가 부착되는 로봇의 팔 메시들 중 "가장 앞에서 렌더링 되는 메시"를 변수에 저장합니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>targetMesh = mainCharacter.GetOptTransform("HandMidGear");</strong></span><br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;void Update()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// A키를 누르면 장비가 부착됩니다.<br>
    &emsp;&emsp;&emsp;&emsp;if(Input.GetKeyDown(KeyCode.A))<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Attach();<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// S키를 누르면 부착이 해제됩니다.<br>
    &emsp;&emsp;&emsp;&emsp;if(Input.GetKeyDown(KeyCode.S))<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Detach();<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;private void Attach()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비를 로봇의 부모 게임 오브젝트의 자식으로 등록합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.parent = robotGroup;<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.localPosition = Vector3.zero;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 본을 동기화합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.Synchronize(mainCharacter, false, false, false, true, SYNC_BONE_OPTION.MatchFromRoot);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 장비가 로봇 팔에 부착될 때, 장비 메시들의 렌더링 순서를 갱신합니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>RefreshMeshDepth();</strong></span><br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;private void Detach()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비를 로봇의 부모 게임 오브젝트로부터 분리합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.parent = null;<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.position = new Vector3(-5, 0, 0);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 동기화를 해제합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.Unsynchronize();<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;// 장비 메시들의 Sorting Order를 갱신합니다.<br>
    &emsp;&emsp;<span class="text-danger"><strong>private void RefreshMeshDepth()</strong></span><br>
    &emsp;&emsp;<span class="text-danger"><strong>{</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;// 로봇 캐릭터의 팔 메시의 Sorting Order를 가져옵니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>int baseSortingOrder = targetMesh.GetSortingOrder();</strong></span><br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 로봇 캐릭터의 팔 메시보다 앞에서 렌더링 되도록 Sorting Order를 하나씩 설정합니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>equipment.SetSortingOrder("Equip4", baseSortingOrder + 1);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>equipment.SetSortingOrder("Equip1", baseSortingOrder + 2);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>equipment.SetSortingOrder("Equip2", baseSortingOrder + 3);</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>equipment.SetSortingOrder("Equip3", baseSortingOrder + 4);</strong></span><br>
    &emsp;&emsp;<span class="text-danger"><strong>}</strong></span><br>
    }<br>
    <br>
    </p>
    </div>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1396.jpg"/>
    <br>
    
    <p>
    수정한 스크립트에 따라 렌더링 순서가 바뀌도록 설정을 바꿔봅시다.<br>
    <strong>(1)</strong> 메인 캐릭터인 로봇 캐릭터를 선택합니다. (장비 캐릭터가 아닙니다.)<br>
    <strong>(2)</strong> <strong>Sorting Order Option</strong>을 <strong>Detph To Order</strong>로 변경하고, <strong>Order Per Depth</strong>를 적당히 큰 <strong>10</strong>으로 설정합니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1397.jpg"/>
    <br>
    
    <p>
    <strong>(1)</strong> 부모 GameObject를 선택합니다.<br>
    <strong>(2)</strong> <strong>Sorting Group</strong> 컴포넌트를 추가합니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1398.jpg"/>
    <br>
    
    <p>
    게임을 실행하고 장비를 로봇에 장착하면 메시들이 정상적으로 렌더링되는 것을 볼 수 있습니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1399.jpg"/>
    <br>
    
    <p>
    하지만 완벽하게 문제가 해결된 것은 아닙니다.<br>
    이 로봇에는 "<strong>Extra 설정</strong>"에 의해서 팔 메시들이 몸의 뒤쪽에서 렌더링되기도 하기 때문입니다.<br>
    로봇 팔이 뒤에서 렌더링 될때도 장비 메시 들은 몸 앞에서 렌더링이 되는 것을 볼 수 있습니다.<br>
    (장비를 부착하는 시점에 따라서는 그 반대일 수 있습니다.)<br>
    </p>
    <br>
    
    <p>
    이전에는 "부착할 때 메시의 Sorting Order를 지정" 했지만, 이 문제를 해결하려면 "실시간으로 메시의 Sorting Order를 갱신"해야합니다.<br>
    스크립트를 더 수정해봅시다.<br>
    </p>
    <br>
    
    <!-- 23. 코드 예시 -->
    <div class="alert alert-warning" role="alert">
    <p>
    <br>
    using UnityEngine;<br>
    using AnyPortrait;<br>
    <br>
    public class RobotDepthSyncScript : MonoBehaviour<br>
    {&emsp;&emsp;<br>
    &emsp;&emsp;public Transform robotGroup; // 로봇의 부모 GameObject입니다.<br>
    &emsp;&emsp;public apPortrait mainCharacter; // 로봇 캐릭터입니다.<br>
    &emsp;&emsp;public apPortrait equipment; // 로봇에 부착될 장비 캐릭터입니다.<br>
    <br>
    &emsp;&emsp;// Sorting Order값을 참조할 로봇 팔의 메시 중 하나를 변수로 저장합니다.<br>
    &emsp;&emsp;private apOptTransform targetMesh;<br>
    <br>
    &emsp;&emsp;// 팔 메시의 렌더링 순서가 갱신되는 것을 검사하기 위한 변수들입니다.<br>
    &emsp;&emsp;<span class="text-danger"><strong>private bool isAttached = false;</strong></span> // 장비가 부착된 상태인지 여부입니다.<br>
    &emsp;&emsp;<span class="text-danger"><strong>private int prevSortingOrder = -1;</strong></span> // 이전 업데이트에서의 targetMesh의 SortingOrder의 값입니다.<br>
    <br>
    &emsp;&emsp;void Start()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비가 부착되는 로봇의 팔 메시들 중 "가장 앞에서 렌더링 되는 메시"를 변수에 저장합니다.<br>
    &emsp;&emsp;&emsp;&emsp;targetMesh = mainCharacter.GetOptTransform("HandMidGear");<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;void Update()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// A키를 누르면 장비가 부착됩니다.<br>
    &emsp;&emsp;&emsp;&emsp;if(Input.GetKeyDown(KeyCode.A))<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Attach();<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// S키를 누르면 부착이 해제됩니다.<br>
    &emsp;&emsp;&emsp;&emsp;if(Input.GetKeyDown(KeyCode.S))<br>
    &emsp;&emsp;&emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Detach();<br>
    &emsp;&emsp;&emsp;&emsp;}<br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;// AnyPortrait 캐릭터의 업데이트가 처리된 이후에 Sorting Order의 값을 참조하기 위해서 LateUpdate()를 이용합니다.<br>
    &emsp;&emsp;<span class="text-danger"><strong>private void LateUpdate()</strong></span><br>
    &emsp;&emsp;<span class="text-danger"><strong>{</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;// 장비가 부착된 상태일 때, 로봇 팔 메시의 렌더링 순서가 바뀌었는지 검사합니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>if (isAttached)</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>{</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>if (targetMesh.GetSortingOrder() != prevSortingOrder)</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>{</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// 팔 메시의 Sorting Order가 이전 프레임과 다르다면, 부착된 장비 메시들의 Sorting Order를 갱신합니다.<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>RefreshMeshDepth();</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// 처리가 완료된 후 현재 프레임의 Sorting Order값으로 갱신합니다.<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>prevSortingOrder = targetMesh.GetSortingOrder();</strong></span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>}</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>}</strong></span><br>
    &emsp;&emsp;<span class="text-danger"><strong>}</strong></span><br>
    <br>
    &emsp;&emsp;private void Attach()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비를 로봇의 부모 게임 오브젝트의 자식으로 등록합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.parent = robotGroup;<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.localPosition = Vector3.zero;<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 본을 동기화합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.Synchronize(mainCharacter, false, false, false, true, SYNC_BONE_OPTION.MatchFromRoot);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 장비가 로봇 팔에 부착될 때, 장비 메시들의 렌더링 순서를 갱신합니다.<br>
    &emsp;&emsp;&emsp;&emsp;RefreshMeshDepth();<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 부착 직후에 팔 메시의 Sorting Order를 저장하고, 부착되었음을 isAttached 변수에 저장합니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>prevSortingOrder = targetMesh.GetSortingOrder();</strong></span><br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>isAttached = true;</strong></span><br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;private void Detach()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 장비를 로봇의 부모 게임 오브젝트로부터 분리합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.parent = null;<br>
    &emsp;&emsp;&emsp;&emsp;equipment.transform.position = new Vector3(-5, 0, 0);<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 동기화를 해제합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.Unsynchronize();<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 부착이 해제되었으므로, LateUpdate()에서 팔 메시의 렌더링 순서를 계속 체크하지 않도록 false를 입력합니다.<br>
    &emsp;&emsp;&emsp;&emsp;<span class="text-danger"><strong>isAttached = false;</strong></span><br>
    &emsp;&emsp;}<br>
    <br>
    &emsp;&emsp;// 장비 메시들의 Sorting Order를 갱신합니다.<br>
    &emsp;&emsp;private void RefreshMeshDepth()<br>
    &emsp;&emsp;{<br>
    &emsp;&emsp;&emsp;&emsp;// 로봇 캐릭터의 팔 메시의 Sorting Order를 가져옵니다.<br>
    &emsp;&emsp;&emsp;&emsp;int baseSortingOrder = targetMesh.GetSortingOrder();<br>
    <br>
    &emsp;&emsp;&emsp;&emsp;// 로봇 캐릭터의 팔 메시보다 앞에서 렌더링 되도록 Sorting Order를 하나씩 설정합니다.<br>
    &emsp;&emsp;&emsp;&emsp;equipment.SetSortingOrder("Equip4", baseSortingOrder + 1);<br>
    &emsp;&emsp;&emsp;&emsp;equipment.SetSortingOrder("Equip1", baseSortingOrder + 2);<br>
    &emsp;&emsp;&emsp;&emsp;equipment.SetSortingOrder("Equip2", baseSortingOrder + 3);<br>
    &emsp;&emsp;&emsp;&emsp;equipment.SetSortingOrder("Equip3", baseSortingOrder + 4);&emsp;&emsp;&emsp;&emsp;<br>
    &emsp;&emsp;}<br>
    }<br>
    <br>
    </p>
    </div>
    <br>
    
    <p>
    수정된 스크립트의 핵심은 "기준이 되는 팔 메시의 <strong>Sorting Order</strong> 값이 바뀌었는지"를 계속 검사하는 것입니다.<br>
    AnyPortrait 캐릭터는 "LateUpdate<strong>()</strong>"에서 업데이트 되므로, 여기서도 "LateUpdate<strong>()</strong>"에서 <strong>Sorting Order</strong>를 검사해야 합니다.<br>
    특히, 이전 프레임의 <strong>Sorting Order</strong>를 별도의 변수(prevSortingOrder)에 저장하여 비교하는 구문을 주의깊게 봐주세요!<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1400.jpg"/>
    <br>
    
    <p>
    "LateUpdate<strong>()</strong>"에서 Sorting Order 값을 검사하도록 작성했지만, 그래도 해당 코드가 AnyPortrait 캐릭터의 업데이트보다 먼저 호출될 수 있습니다.<br>
    이 경우엔 정상적으로 "현재의 Sorting Order"를 확인하기가 어렵습니다.<br>
    이 스크립트가 AnyPortrait보다 나중에 동작하도록 만들어야 합니다.<br>
    (비슷한 이슈에 대해서 <a href="../../kr/AdvancedManual/AD_ExecutionOrderProblem.html">관련 페이지</a>에서도 다루고 있습니다.)<br>
    <strong>(1)</strong> 유니티의 "<strong>Project Settings</strong>"를 열고 "<strong>Script Execution Order</strong>"를 선택합니다.<br>
    <strong>(2)</strong> 작성한 스크립트를 드래그하여 스크립트 목록에 추가한 후, "<strong>Default Time</strong>"보다 아래에 위치시킵니다.<br>
    </p>
    <br>
    
    <!-- 8. 이미지 (가운데 정렬) -->
    <br>
    <img class="img-fluid rounded-sm mx-auto d-block" style="max-width:80%;" src="../../Images/Advanced/AdManual_1401.jpg"/>
    <br>
    
    <p>
    게임을 실행하면 로봇의 팔의 움직임, 렌더링 순서에 맞게 장비들이 움직이고 렌더링되는 것을 볼 수 있습니다.<br>
    </p>
    <br>
    
    <!-- 12. 참고 박스 시작 -->
    <div class="alert alert-info" role="alert">
    
    <!-- 3. 서브 타이틀(참고 박스) -->
    <h4>Sorting Order의 변화를 감지하는 방법에 대하여</h4>
    <br>
    
    <p>
    이 페이지에서는 특정 메시를 변수로 저장한 후, Sorting Order의 변화를 체크하였습니다.<br>
    그 외에도 "Extra 설정을 결정하는 컨트롤 파라미터의 값"을 이용하거나 "애니메이션 이벤트"를 이용하는 것도 가능합니다.<br>
    </p>
    <br>
    
    </div>
    <br>
    <br>
    
    <!-- 12. 참고 박스 시작 -->
    <div class="alert alert-info" role="alert">
    
    <!-- 3. 서브 타이틀(참고 박스) -->
    <h4>부착되는 메시에 Sorting Order를 할당하기</h4>
    <br>
    
    <p>
    제작하는 일러스트에 따라서 메시들의 순서가 정해질 것입니다.<br>
    따라서 부착되는 메시가 어느 메시의 앞, 뒤에 배치될 지는 여러분이 정하시면 됩니다.<br>
    이 페이지에서의 경우처럼 메시들의 이름과 순서를 스크립트에서 직접 지정하는 것이 빠르고 간편합니다.<br>
    하지만 다양한 객체들을 부착하고자 한다면 별도의 데이터나 규칙을 정해서 스크립트를 작성하는 것이 좋을 것입니다.<br>
    </p>
    <br>
    
    </div>
    <br>
    <br>
    
    <!-- 12. 참고 박스 시작 -->
    <div class="alert alert-info" role="alert">
    
    <!-- 3. 서브 타이틀(참고 박스) -->
    <h4>메시를 합쳤을 때의 드로우콜(Drawcall)에 대하여</h4>
    <br>
    
    <p>
    서로 다른 이미지나 재질을 가진 메시들이 엇갈려서 렌더링되는 경우 드로우콜이 크게 증가합니다.<br>
    이것을 해결하기 위해서는 이미지를 공유하거나 특별한 재질을 만들어야합니다.<br>
    저희 팀은 이 경우에 드로우콜의 증가를 최소화할 수 있는 기능을 고려하고 있습니다.<br>
    이에 대한 의견을 주시면 개발에 적극 반영하겠습니다.<br>
    </p>
    <br>
    
    </div>
    <br>
    <br>
    
    <!-- 5. 바닥 네비바 -->
    <br>
    <br>
    <br>
    <br>
    <nav class="navbar fixed-bottom navbar-light bg-light">
        <a class="btn btn-light" role="button" href="../../kr/AdvancedManual/AD_SyncBonesToChangeCostumes.html">< 본을 동기화하여 의상 교체하기</a>
        <a class="btn btn-light" role="button" href="../../kr/AdvancedManual/AD_BuildiOSPlatforms.html">iOS 및 다른 플랫폼으로 빌드하기 ></a>
    </nav>
    
    <!-- 페이지 내용 끝! -->

    
    <!-- 종료 -->
    </div>

    <!-- 부트스트랩 -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script type="text/javascript" src="../../js/bootstrap.js"></script>
    <!--------------->

    </body>
</html>
